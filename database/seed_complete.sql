-- Complete Seed Data: 40 LeetCode + 10 ML System Design Questions
-- Optimized for Meta & Atlassian Senior ML Engineer Interviews
-- Generated by generate_seed_sql.py
-- 
-- Distribution:
--   LeetCode: 8 Easy, 35 Medium, 8 Hard = 51 Total
--   ML Design: 10 questions
--
-- Meta-specific additions: Sparse Vectors, K Closest Points, Buildings with Ocean View, etc.
-- Atlassian-specific: Search/Discovery system for Jira/Confluence

-- Ensure categories exist
INSERT OR IGNORE INTO question_categories (id, name, description) VALUES
    (1, 'leetcode', 'LeetCode-style coding problems'),
    (2, 'ml_system_design', 'Machine Learning System Design questions');

-- ============================================
-- LEETCODE QUESTIONS
-- ============================================

-- Question 1: Two Sum
-- Two Sum (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(1, 1, 'Two Sum', 'easy',
'Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.',
'["2 <= nums.length <= 10^4", "-10^9 <= nums[i] <= 10^9", "-10^9 <= target <= 10^9", "Only one valid answer exists"]',
'[{"input": {"nums": [2, 7, 11, 15], "target": 9}, "output": [0, 1], "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."}, {"input": {"nums": [3, 2, 4], "target": 6}, "output": [1, 2], "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."}]',
'["array", "hash-table"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Think about the array indices and how you can traverse or manipulate them.", "Start with a brute force approach, then optimize if needed.", "Consider what pairs or combinations of numbers could sum to the target.", "LeetCode URL: https://leetcode.com/problems/two-sum/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(1,
'class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        pass',
'class Solution {
    public int[] twoSum(int[] nums, int target) {
        
    }
}',
'class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
    }
};',
'[{"input": [[2, 7, 11, 15], 9], "expectedOutput": [0, 1]}, {"input": [[3, 2, 4], 6], "expectedOutput": [1, 2]}, {"input": [[3, 3], 6], "expectedOutput": [0, 1]}]',
'[]',
'O(n)',
'O(n)',
'class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # Hash map approach for O(n) time complexity
        num_map = {}

        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                return [num_map[complement], i]
            num_map[num] = i

        return []',
'class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }

        return new int[] {};
    }
}',
'class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;

        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }
            numMap[nums[i]] = i;
        }

        return {};
    }
};',
'## Approach: Hash Table

### Algorithm
1. Create a hash map to store values and indices
2. For each number, calculate its complement (target - num)
3. Check if complement exists in hash map
4. If found, return indices; otherwise add current number to map

### Complexity Analysis
- **Time Complexity**: O(n) - Single pass through the array
- **Space Complexity**: O(n) - Hash map storage');


-- Question 2: Valid Parentheses
-- Valid Parentheses (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(2, 1, 'Valid Parentheses', 'easy',
'Given a string s containing just the characters ''('', '')'', ''{'', ''}'', ''['' and '']'', determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.',
'["1 <= s.length <= 10^4", "s consists of parentheses only ''()[]{}''"]',
'[{"input": {"s": "()"}, "output": true, "explanation": "The string is valid."}, {"input": {"s": "()[]{}"}, "output": true, "explanation": "All brackets are properly closed."}, {"input": {"s": "(]"}, "output": false, "explanation": "Mismatched brackets."}]',
'["string", "stack"]',
'["A stack data structure (LIFO) might be useful here.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Start with a brute force approach, then optimize if needed.", "Track opening and closing brackets, ensuring they match correctly.", "LeetCode URL: https://leetcode.com/problems/valid-parentheses/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(2,
'class Solution:
    def isValid(self, s: str) -> bool:
        pass',
'class Solution {
    public boolean isValid(String s) {
        
    }
}',
'class Solution {
public:
    bool isValid(string s) {
        
    }
};',
'[{"input": ["()"], "expectedOutput": true}, {"input": ["()[]{}"], "expectedOutput": true}, {"input": ["(]"], "expectedOutput": false}, {"input": ["([)]"], "expectedOutput": false}]',
'[]',
'O(n)',
'O(n)',
'class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {'')'': ''('', ''}'': ''{'', '']'': ''[''}

        for char in s:
            if char in mapping:
                if not stack or stack[-1] != mapping[char]:
                    return False
                stack.pop()
            else:
                stack.append(char)

        return len(stack) == 0',
'class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        Map<Character, Character> map = new HashMap<>();
        map.put('')'', ''('');
        map.put(''}'', ''{'');
        map.put('']'', ''['');

        for (char c : s.toCharArray()) {
            if (map.containsKey(c)) {
                if (stack.isEmpty() || stack.peek() != map.get(c)) {
                    return False;
                }
                stack.pop();
            } else {
                stack.push(c);
            }
        }

        return stack.isEmpty();
    }
}',
'class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> mapping = {
            {'')'', ''(''},
            {''}'', ''{''},
            {'']'', ''[''}
        };

        for (char c : s) {
            if (mapping.count(c)) {
                if (st.empty() || st.top() != mapping[c]) {
                    return False;
                }
                st.pop();
            } else {
                st.push(c);
            }
        }

        return st.empty();
    }
};',
'## Approach: Stack

### Algorithm
1. Use a stack to track opening brackets
2. For closing brackets, check if they match the most recent opening bracket
3. Valid if all brackets are matched (stack is empty)

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)');


-- Question 3: Merge Two Sorted Lists
-- Merge Two Sorted Lists (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(3, 1, 'Merge Two Sorted Lists', 'easy',
'You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.',
'["The number of nodes in both lists is in the range [0, 50]", "-100 <= Node.val <= 100", "Both list1 and list2 are sorted in non-decreasing order"]',
'[{"input": {"list1": [1, 2, 4], "list2": [1, 3, 4]}, "output": [1, 1, 2, 3, 4, 4], "explanation": "Merge both sorted lists."}, {"input": {"list1": [], "list2": []}, "output": [], "explanation": "Both lists are empty."}]',
'["linked-list", "recursion"]',
'["Start with a brute force approach, then optimize if needed.", "Think about how to combine two sorted sequences efficiently.", "LeetCode URL: https://leetcode.com/problems/merge-two-sorted-lists/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(3,
'class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        
    }
}',
'class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        
    }
};',
'[{"input": [[1, 2, 4], [1, 3, 4]], "expectedOutput": [1, 1, 2, 3, 4, 4]}, {"input": [[], []], "expectedOutput": []}, {"input": [[], [0]], "expectedOutput": [0]}]',
'[]',
'O(n+m)',
'O(1)',
'class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        current = dummy

        while list1 and list2:
            if list1.val <= list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next

        current.next = list1 if list1 else list2
        return dummy.next',
'class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (list1 != None && list2 != None) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }

        current.next = (list1 != None) ? list1 : list2;
        return dummy.next;
    }
}',
'class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy(0);
        ListNode* current = &dummy;

        while (list1 && list2) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }

        current->next = list1 ? list1 : list2;
        return dummy.next;
    }
};',
'## Approach: Iterative Merge

### Algorithm
1. Use dummy node to simplify edge cases
2. Compare nodes and attach smaller one
3. Attach remaining list when one is exhausted

### Complexity Analysis
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(1)');


-- Question 4: Best Time to Buy and Sell Stock
-- Best Time to Buy and Sell Stock (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(4, 1, 'Best Time to Buy and Sell Stock', 'easy',
'You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.',
'["1 <= prices.length <= 10^5", "0 <= prices[i] <= 10^4"]',
'[{"input": {"prices": [7, 1, 5, 3, 6, 4]}, "output": 5, "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."}, {"input": {"prices": [7, 6, 4, 3, 1]}, "output": 0, "explanation": "In this case, no transactions are done and the max profit = 0."}]',
'["array", "dynamic-programming"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "Start with a brute force approach, then optimize if needed.", "LeetCode URL: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(4,
'class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        pass',
'class Solution {
    public int maxProfit(int[] prices) {
        
    }
}',
'class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
    }
};',
'[{"input": [[7, 1, 5, 3, 6, 4]], "expectedOutput": 5}, {"input": [[7, 6, 4, 3, 1]], "expectedOutput": 0}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = float(''inf'')
        max_profit = 0

        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)

        return max_profit',
'class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;

        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }

        return maxProfit;
    }
}',
'class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit = 0;

        for (int price : prices) {
            minPrice = min(minPrice, price);
            maxProfit = max(maxProfit, price - minPrice);
        }

        return maxProfit;
    }
};',
'## Approach: Dynamic Programming

### Algorithm
1. Track minimum price seen so far
2. Calculate profit at each day
3. Keep maximum profit

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)');


-- Question 5: Valid Palindrome
-- Valid Palindrome (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(5, 1, 'Valid Palindrome', 'easy',
'A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return True if it is a palindrome, or False otherwise.',
'["1 <= s.length <= 2 * 10^5", "s consists only of printable ASCII characters"]',
'[{"input": {"s": "A man, a plan, a canal: Panama"}, "output": true, "explanation": "After cleaning: amanaplanacanalpanama which is a palindrome."}, {"input": {"s": "race a car"}, "output": false, "explanation": "After cleaning: raceacar which is not a palindrome."}]',
'["two-pointers", "string"]',
'["Try using two pointers - one starting from the beginning and one from the end.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Start with a brute force approach, then optimize if needed.", "LeetCode URL: https://leetcode.com/problems/valid-palindrome/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(5,
'class Solution:
    def isPalindrome(self, s: str) -> bool:
        pass',
'class Solution {
    public boolean isPalindrome(String s) {
        
    }
}',
'class Solution {
public:
    bool isPalindrome(string s) {
        
    }
};',
'[{"input": ["A man, a plan, a canal: Panama"], "expectedOutput": true}, {"input": ["race a car"], "expectedOutput": false}, {"input": [" "], "expectedOutput": true}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def isPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1

        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1

            if s[left].lower() != s[right].lower():
                return False

            left += 1
            right -= 1

        return True',
'class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;

        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }

            if (Character.toLowerCase(s.charAt(left)) !=
                Character.toLowerCase(s.charAt(right))) {
                return False;
            }

            left++;
            right--;
        }

        return True;
    }
}',
'class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.length() - 1;

        while (left < right) {
            while (left < right && !isalnum(s[left])) {
                left++;
            }
            while (left < right && !isalnum(s[right])) {
                right--;
            }

            if (tolower(s[left]) != tolower(s[right])) {
                return False;
            }

            left++;
            right--;
        }

        return True;
    }
};',
'## Approach: Two Pointers

### Algorithm
1. Use two pointers from start and end
2. Skip non-alphanumeric characters
3. Compare characters (case-insensitive)

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)');


-- Question 6: Climbing Stairs
-- Climbing Stairs (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(6, 1, 'Climbing Stairs', 'easy',
'You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?',
'["1 <= n <= 45"]',
'[{"input": {"n": 2}, "output": 2, "explanation": "There are two ways: 1. 1 step + 1 step, 2. 2 steps"}, {"input": {"n": 3}, "output": 3, "explanation": "There are three ways: 1. 1+1+1, 2. 1+2, 3. 2+1"}]',
'["dynamic-programming", "math"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Start with a brute force approach, then optimize if needed.", "LeetCode URL: https://leetcode.com/problems/climbing-stairs/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(6,
'class Solution:
    def climbStairs(self, n: int) -> int:
        pass',
'class Solution {
    public int climbStairs(int n) {
        
    }
}',
'class Solution {
public:
    int climbStairs(int n) {
        
    }
};',
'[{"input": [2], "expectedOutput": 2}, {"input": [3], "expectedOutput": 3}, {"input": [4], "expectedOutput": 5}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n

        # Dynamic programming - Fibonacci sequence
        prev2, prev1 = 1, 2

        for i in range(3, n + 1):
            current = prev1 + prev2
            prev2 = prev1
            prev1 = current

        return prev1',
'class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;

        int prev2 = 1, prev1 = 2;

        for (int i = 3; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }

        return prev1;
    }
}',
'class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;

        int prev2 = 1, prev1 = 2;

        for (int i = 3; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }

        return prev1;
    }
};',
'## Approach: Dynamic Programming (Fibonacci)

### Algorithm
1. Base cases: 1 step = 1 way, 2 steps = 2 ways
2. For n steps: ways(n) = ways(n-1) + ways(n-2)
3. Use two variables to track previous values

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)');


-- Question 7: Binary Tree Inorder Traversal
-- Binary Tree Inorder Traversal (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(7, 1, 'Binary Tree Inorder Traversal', 'easy',
'Given the root of a binary tree, return the inorder traversal of its nodes'' values.

Inorder traversal: Left -> Root -> Right',
'["The number of nodes in the tree is in the range [0, 100]", "-100 <= Node.val <= 100"]',
'[{"input": {"root": [1, null, 2, 3]}, "output": [1, 3, 2], "explanation": "Inorder traversal of the tree."}, {"input": {"root": []}, "output": [], "explanation": "Empty tree."}]',
'["tree", "depth-first-search", "stack"]',
'["A stack data structure (LIFO) might be useful here.", "Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Start with a brute force approach, then optimize if needed.", "LeetCode URL: https://leetcode.com/problems/binary-tree-inorder-traversal/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(7,
'class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        pass',
'class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
    }
}',
'class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        
    }
};',
'[{"input": [[1, null, 2, 3]], "expectedOutput": [1, 3, 2]}, {"input": [[]], "expectedOutput": []}, {"input": [[1]], "expectedOutput": [1]}]',
'[]',
'O(n)',
'O(n)',
'class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        stack = []
        current = root

        while current or stack:
            # Go to the leftmost node
            while current:
                stack.append(current)
                current = current.left

            # Current is None, so process the node on top of stack
            current = stack.pop()
            result.append(current.val)

            # Visit right subtree
            current = current.right

        return result',
'class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != None || !stack.isEmpty()) {
            while (current != None) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            result.add(current.val);
            current = current.right;
        }

        return result;
    }
}',
'class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* current = root;

        while (current || !st.empty()) {
            while (current) {
                st.push(current);
                current = current->left;
            }

            current = st.top();
            st.pop();
            result.push_back(current->val);
            current = current->right;
        }

        return result;
    }
};',
'## Approach: Iterative using Stack

### Algorithm
1. Use stack to simulate recursion
2. Go left as far as possible
3. Process node and go right

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)');


-- Question 8: Linked List Cycle
-- Linked List Cycle (EASY)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(8, 1, 'Linked List Cycle', 'easy',
'Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.',
'["The number of the nodes in the list is in the range [0, 10^4]", "-10^5 <= Node.val <= 10^5", "pos is -1 or a valid index in the linked-list"]',
'[{"input": {"head": [3, 2, 0, -4], "pos": 1}, "output": true, "explanation": "There is a cycle where the tail connects to the 1st node."}, {"input": {"head": [1], "pos": -1}, "output": false, "explanation": "There is no cycle in the linked list."}]',
'["linked-list", "two-pointers", "hash-table"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Try using two pointers - one starting from the beginning and one from the end.", "Start with a brute force approach, then optimize if needed.", "LeetCode URL: https://leetcode.com/problems/linked-list-cycle/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(8,
'class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        pass',
'class Solution {
    public boolean hasCycle(ListNode head) {
        
    }
}',
'class Solution {
public:
    bool hasCycle(ListNode *head) {
        
    }
};',
'[{"input": [[3, 2, 0, -4], 1], "expectedOutput": true}, {"input": [[1, 2], 0], "expectedOutput": true}, {"input": [[1], -1], "expectedOutput": false}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False

        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next

        return True',
'public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == None || head.next == None) {
            return False;
        }

        ListNode slow = head;
        ListNode fast = head.next;

        while (slow != fast) {
            if (fast == None || fast.next == None) {
                return False;
            }
            slow = slow.next;
            fast = fast.next.next;
        }

        return True;
    }
}',
'class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next) return False;

        ListNode* slow = head;
        ListNode* fast = head->next;

        while (slow != fast) {
            if (!fast || !fast->next) return False;
            slow = slow->next;
            fast = fast->next->next;
        }

        return True;
    }
};',
'## Approach: Floyd''s Cycle Detection (Two Pointers)

### Algorithm
1. Use slow and fast pointers
2. Slow moves 1 step, fast moves 2 steps
3. If they meet, there''s a cycle

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)');


-- Question 9: Longest Substring Without Repeating Characters
-- Longest Substring Without Repeating Characters (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(9, 1, 'Longest Substring Without Repeating Characters', 'medium',
'Given a string s, find the length of the longest substring without repeating characters.',
'["0 <= s.length <= 5 * 10^4", "s consists of English letters, digits, symbols and spaces"]',
'[{"input": {"s": "abcabcbb"}, "output": 3, "explanation": "The answer is ''abc'', with the length of 3."}, {"input": {"s": "bbbbb"}, "output": 1, "explanation": "The answer is ''b'', with the length of 1."}]',
'["string", "sliding-window", "hash-table"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Consider maintaining a window of elements that slides through the array.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/longest-substring-without-repeating-characters/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(9,
'class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        pass',
'class Solution {
    public int lengthOfLongestSubstring(String s) {
        
    }
}',
'class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
    }
};',
'[{"input": ["abcabcbb"], "expectedOutput": 3}, {"input": ["bbbbb"], "expectedOutput": 1}, {"input": ["pwwkew"], "expectedOutput": 3}]',
'[]',
'O(n)',
'O(min(m,n))',
'class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_set = set()
        left = 0
        max_length = 0

        for right in range(len(s)):
            while s[right] in char_set:
                char_set.remove(s[left])
                left += 1

            char_set.add(s[right])
            max_length = max(max_length, right - left + 1)

        return max_length',
'class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> charSet = new HashSet<>();
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            while (charSet.contains(s.charAt(right))) {
                charSet.remove(s.charAt(left));
                left++;
            }

            charSet.add(s.charAt(right));
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}',
'class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> charSet;
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            while (charSet.count(s[right])) {
                charSet.erase(s[left]);
                left++;
            }

            charSet.insert(s[right]);
            maxLength = max(maxLength, right - left + 1);
        }

        return maxLength;
    }
};',
'## Approach: Sliding Window with Hash Set

### Algorithm
1. Use two pointers for sliding window
2. Expand window by moving right pointer
3. Contract window when duplicate found
4. Track maximum window size

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(min(n, m)) where m is charset size');


-- Question 10: Add Two Numbers
-- Add Two Numbers (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(10, 1, 'Add Two Numbers', 'medium',
'You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.',
'["The number of nodes in each linked list is in the range [1, 100]", "0 <= Node.val <= 9", "It is guaranteed that the list represents a number that does not have leading zeros"]',
'[{"input": {"l1": [2, 4, 3], "l2": [5, 6, 4]}, "output": [7, 0, 8], "explanation": "342 + 465 = 807."}, {"input": {"l1": [0], "l2": [0]}, "output": [0], "explanation": "0 + 0 = 0."}]',
'["linked-list", "math", "recursion"]',
'["Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/add-two-numbers/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(10,
'class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
    }
}',
'class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        
    }
};',
'[{"input": [[2, 4, 3], [5, 6, 4]], "expectedOutput": [7, 0, 8]}, {"input": [[0], [0]], "expectedOutput": [0]}, {"input": [[9, 9, 9], [9, 9, 9, 9]], "expectedOutput": [8, 9, 9, 0, 1]}]',
'[]',
'O(max(m,n))',
'O(max(m,n))',
'class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        current = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            total = val1 + val2 + carry
            carry = total // 10

            current.next = ListNode(total % 10)
            current = current.next

            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next',
'class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;

        while (l1 != None || l2 != None || carry != 0) {
            int val1 = (l1 != None) ? l1.val : 0;
            int val2 = (l2 != None) ? l2.val : 0;

            int total = val1 + val2 + carry;
            carry = total / 10;

            current.next = new ListNode(total % 10);
            current = current.next;

            l1 = (l1 != None) ? l1.next : None;
            l2 = (l2 != None) ? l2.next : None;
        }

        return dummy.next;
    }
}',
'class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* current = &dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int val1 = l1 ? l1->val : 0;
            int val2 = l2 ? l2->val : 0;

            int total = val1 + val2 + carry;
            carry = total / 10;

            current->next = new ListNode(total % 10);
            current = current->next;

            l1 = l1 ? l1->next : Noneptr;
            l2 = l2 ? l2->next : Noneptr;
        }

        return dummy.next;
    }
};',
'## Approach: Elementary Math with Carry

### Algorithm
1. Add digits and carry from right to left
2. Handle carry for next position
3. Continue until both lists exhausted and no carry

### Complexity Analysis
- **Time Complexity**: O(max(m, n))
- **Space Complexity**: O(max(m, n))');


-- Question 11: Container With Most Water
-- Container With Most Water (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(11, 1, 'Container With Most Water', 'medium',
'You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.',
'["n == height.length", "2 <= n <= 10^5", "0 <= height[i] <= 10^4"]',
'[{"input": {"height": [1, 8, 6, 2, 5, 4, 8, 3, 7]}, "output": 49, "explanation": "The max area is between index 1 (height 8) and index 8 (height 7)."}]',
'["array", "two-pointers", "greedy"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Try using two pointers - one starting from the beginning and one from the end.", "Try making the locally optimal choice at each step.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/container-with-most-water/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(11,
'class Solution:
    def maxArea(self, height: List[int]) -> int:
        pass',
'class Solution {
    public int maxArea(int[] height) {
        
    }
}',
'class Solution {
public:
    int maxArea(vector<int>& height) {
        
    }
};',
'[{"input": [[1, 8, 6, 2, 5, 4, 8, 3, 7]], "expectedOutput": 49}, {"input": [[1, 1]], "expectedOutput": 1}, {"input": [[4, 3, 2, 1, 4]], "expectedOutput": 16}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0

        while left < right:
            width = right - left
            current_area = min(height[left], height[right]) * width
            max_area = max(max_area, current_area)

            # Move the pointer with smaller height
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1

        return max_area',
'class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            int width = right - left;
            int currentArea = Math.min(height[left], height[right]) * width;
            maxArea = Math.max(maxArea, currentArea);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}',
'class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int maxArea = 0;

        while (left < right) {
            int width = right - left;
            int currentArea = min(height[left], height[right]) * width;
            maxArea = max(maxArea, currentArea);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
};',
'## Approach: Two Pointers

### Algorithm
1. Start with widest container
2. Move pointer with smaller height inward
3. Track maximum area

### Complexity Analysis
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)');


-- Question 12: 3Sum
-- 3Sum (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(12, 1, '3Sum', 'medium',
'Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.',
'["3 <= nums.length <= 3000", "-10^5 <= nums[i] <= 10^5"]',
'[{"input": {"nums": [-1, 0, 1, 2, -1, -4]}, "output": [[-1, -1, 2], [-1, 0, 1]], "explanation": "The distinct triplets are [-1,0,1] and [-1,-1,2]."}, {"input": {"nums": [0, 1, 1]}, "output": [], "explanation": "The only possible triplet does not sum up to 0."}]',
'["array", "two-pointers", "sorting"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Try using two pointers - one starting from the beginning and one from the end.", "Would sorting the input help simplify the problem?", "Think about the time and space complexity trade-offs.", "Consider what pairs or combinations of numbers could sum to the target.", "LeetCode URL: https://leetcode.com/problems/3sum/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(12,
'class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        pass',
'class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        
    }
}',
'class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        
    }
};',
'[{"input": [[-1, 0, 1, 2, -1, -4]], "expectedOutput": [[-1, -1, 2], [-1, 0, 1]]}, {"input": [[0, 1, 1]], "expectedOutput": []}, {"input": [[0, 0, 0]], "expectedOutput": [[0, 0, 0]]}]',
'[]',
'O(n^2)',
'O(1)',
'class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        result = []

        for i in range(len(nums) - 2):
            # Skip duplicates
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, len(nums) - 1

            while left < right:
                total = nums[i] + nums[left] + nums[right]

                if total == 0:
                    result.append([nums[i], nums[left], nums[right]])

                    # Skip duplicates
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1

                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return result',
'class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1, right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }
}',
'class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;

        for (int i = 0; i < nums.size() - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1, right = nums.size() - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    result.push_back({nums[i], nums[left], nums[right]});

                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }
};',
'## Approach: Sort + Two Pointers

### Algorithm
1. Sort the array
2. Fix one element and find two others using two pointers
3. Skip duplicates to avoid duplicate triplets

### Complexity Analysis
- **Time Complexity**: O(nÂ²)
- **Space Complexity**: O(1)');


-- Question 13: Group Anagrams
-- Group Anagrams (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(13, 1, 'Group Anagrams', 'medium',
'Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.',
'["1 <= strs.length <= 10^4", "0 <= strs[i].length <= 100", "strs[i] consists of lowercase English letters"]',
'[{"input": {"strs": ["eat", "tea", "tan", "ate", "nat", "bat"]}, "output": [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]], "explanation": "Group words that are anagrams."}]',
'["array", "hash-table", "string", "sorting"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Think about the array indices and how you can traverse or manipulate them.", "Would sorting the input help simplify the problem?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/group-anagrams/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(13,
'class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        pass',
'class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        
    }
}',
'class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
    }
};',
'[{"input": [["eat", "tea", "tan", "ate", "nat", "bat"]], "expectedOutput": [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]}, {"input": [[""]], "expectedOutput": [[""]]}, {"input": [["a"]], "expectedOutput": [["a"]]}]',
'[]',
'O(n*k)',
'O(n*k)',
'class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagram_map = {}

        for s in strs:
            # Sort the string to create a key
            key = ''''.join(sorted(s))
            if key not in anagram_map:
                anagram_map[key] = []
            anagram_map[key].append(s)

        return list(anagram_map.values())',
'class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();

        for (String s : strs) {
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = String.valueOf(chars);

            if (!map.containsKey(key)) {
                map.put(key, new ArrayList<>());
            }
            map.get(key).add(s);
        }

        return new ArrayList<>(map.values());
    }
}',
'class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;

        for (string& s : strs) {
            string key = s;
            sort(key.begin(), key.end());
            map[key].push_back(s);
        }

        vector<vector<string>> result;
        for (auto& pair : map) {
            result.push_back(pair.second);
        }

        return result;
    }
};',
'## Approach: Hash Map with Sorted String Key

### Algorithm
1. Sort each string to create a key
2. Group strings with the same sorted key
3. Return all groups

### Complexity Analysis
- **Time Complexity**: O(n * k log k) where k is max string length
- **Space Complexity**: O(n * k)');


-- Question 14: Longest Palindromic Substring
-- Longest Palindromic Substring (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(14, 1, 'Longest Palindromic Substring', 'medium',
'Given a string s, return the longest palindromic substring in s.',
'["1 <= s.length <= 1000", "s consist of only digits and English letters"]',
'[{"input": {"s": "babad"}, "output": "bab", "explanation": "Note: ''aba'' is also a valid answer."}, {"input": {"s": "cbbd"}, "output": "bb", "explanation": "The longest palindrome is ''bb''."}]',
'["string", "dynamic-programming"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/longest-palindromic-substring/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(14,
'class Solution:
    def longestPalindrome(self, s: str) -> str:
        pass',
'class Solution {
    public String longestPalindrome(String s) {
        
    }
}',
'class Solution {
public:
    string longestPalindrome(string s) {
        
    }
};',
'[{"input": ["babad"], "expectedOutput": "bab"}, {"input": ["cbbd"], "expectedOutput": "bb"}, {"input": ["a"], "expectedOutput": "a"}]',
'[]',
'O(n^2)',
'O(1)',
'class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""

        def expandAroundCenter(left: int, right: int) -> int:
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return right - left - 1

        start = 0
        max_len = 0

        for i in range(len(s)):
            # Odd length palindromes
            len1 = expandAroundCenter(i, i)
            # Even length palindromes
            len2 = expandAroundCenter(i, i + 1)

            current_len = max(len1, len2)

            if current_len > max_len:
                max_len = current_len
                start = i - (current_len - 1) // 2

        return s[start:start + max_len]',
'class Solution {
    public String longestPalindrome(String s) {
        if (s == None || s.length() == 0) return "";

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);

            if (len > maxLen) {
                maxLen = len;
                start = i - (len - 1) / 2;
            }
        }

        return s.substring(start, start + maxLen);
    }

    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}',
'class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = max(len1, len2);

            if (len > maxLen) {
                maxLen = len;
                start = i - (len - 1) / 2;
            }
        }

        return s.substr(start, maxLen);
    }

private:
    int expandAroundCenter(string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
};',
'## Approach: Expand Around Centers

### Algorithm
1. For each position, consider it as center
2. Expand outward while characters match
3. Handle both odd and even length palindromes

### Complexity Analysis
- **Time Complexity**: O(nÂ²)
- **Space Complexity**: O(1)');


-- Question 15: Product of Array Except Self
-- Product of Array Except Self (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(15, 1, 'Product of Array Except Self', 'medium',
'Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

You must write an algorithm that runs in O(n) time and without using the division operation.',
'["2 <= nums.length <= 10^5", "-30 <= nums[i] <= 30", "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer"]',
'[{"input": {"nums": [1, 2, 3, 4]}, "output": [24, 12, 8, 6], "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."}]',
'["array", "prefix-sum"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/product-of-array-except-self/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(15,
'class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        pass',
'class Solution {
    public int[] productExceptSelf(int[] nums) {
        
    }
}',
'class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        
    }
};',
'[{"input": [[1, 2, 3, 4]], "expectedOutput": [24, 12, 8, 6]}, {"input": [[-1, 1, 0, -3, 3]], "expectedOutput": [0, 0, 9, 0, 0]}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        """
        Two-pass approach using prefix and suffix products.
        Builds result array where result[i] = product of all elements except nums[i].
        Avoids division operator and runs in O(n) time.

        Algorithm:
        1. First pass: Calculate prefix products (product of all elements before i)
        2. Second pass: Multiply by suffix products (product of all elements after i)

        Time Complexity: O(n) - two passes through array
        Space Complexity: O(1) - excluding output array (no extra space used)
        """
        n = len(nums)
        result = [1] * n

        # First pass: Calculate prefix products
        # result[i] = product of all elements before index i
        prefix = 1
        for i in range(n):
            result[i] = prefix
            prefix *= nums[i]

        # Second pass: Multiply by suffix products
        # result[i] *= product of all elements after index i
        suffix = 1
        for i in range(n - 1, -1, -1):
            result[i] *= suffix
            suffix *= nums[i]

        return result
',
'// Solution for Product of Array Except Self
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Product of Array Except Self
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Product of Array Except Self

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 16: Spiral Matrix
-- Spiral Matrix (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(16, 1, 'Spiral Matrix', 'medium',
'Given an m x n matrix, return all elements of the matrix in spiral order.',
'["m == matrix.length", "n == matrix[i].length", "1 <= m, n <= 10", "-100 <= matrix[i][j] <= 100"]',
'[{"input": {"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, "output": [1, 2, 3, 6, 9, 8, 7, 4, 5], "explanation": "Traverse the matrix in spiral order."}]',
'["array", "matrix", "simulation"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/spiral-matrix/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(16,
'class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        pass',
'class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        
    }
}',
'class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        
    }
};',
'[{"input": [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], "expectedOutput": [1, 2, 3, 6, 9, 8, 7, 4, 5]}, {"input": [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]], "expectedOutput": [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]}]',
'[]',
'O(m*n)',
'O(1)',
'# Solution for Spiral Matrix
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Spiral Matrix
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Spiral Matrix
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Spiral Matrix

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 17: Rotate Image
-- Rotate Image (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(17, 1, 'Rotate Image', 'medium',
'You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly.',
'["n == matrix.length == matrix[i].length", "1 <= n <= 20", "-1000 <= matrix[i][j] <= 1000"]',
'[{"input": {"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, "output": [[7, 4, 1], [8, 5, 2], [9, 6, 3]], "explanation": "Rotate 90 degrees clockwise."}]',
'["array", "matrix"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/rotate-image/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(17,
'class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        pass',
'class Solution {
    public void rotate(int[][] matrix) {
        
    }
}',
'class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        
    }
};',
'[{"input": [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], "expectedOutput": [[7, 4, 1], [8, 5, 2], [9, 6, 3]]}, {"input": [[[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]], "expectedOutput": [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]}]',
'[]',
'O(n^2)',
'O(1)',
'# Solution for Rotate Image
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Rotate Image
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Rotate Image
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Rotate Image

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 18: Set Matrix Zeroes
-- Set Matrix Zeroes (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(18, 1, 'Set Matrix Zeroes', 'medium',
'Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0''s.

You must do it in place.',
'["m == matrix.length", "n == matrix[0].length", "1 <= m, n <= 200", "-2^31 <= matrix[i][j] <= 2^31 - 1"]',
'[{"input": {"matrix": [[1, 1, 1], [1, 0, 1], [1, 1, 1]]}, "output": [[1, 0, 1], [0, 0, 0], [1, 0, 1]], "explanation": "Mark row and column of 0s."}]',
'["array", "matrix", "hash-table"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/set-matrix-zeroes/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(18,
'class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        pass',
'class Solution {
    public void setZeroes(int[][] matrix) {
        
    }
}',
'class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        
    }
};',
'[{"input": [[[1, 1, 1], [1, 0, 1], [1, 1, 1]]], "expectedOutput": [[1, 0, 1], [0, 0, 0], [1, 0, 1]]}, {"input": [[[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]], "expectedOutput": [[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]}]',
'[]',
'O(m*n)',
'O(1)',
'# Solution for Set Matrix Zeroes
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Set Matrix Zeroes
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Set Matrix Zeroes
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Set Matrix Zeroes

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 19: Subarray Sum Equals K
-- Subarray Sum Equals K (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(19, 1, 'Subarray Sum Equals K', 'medium',
'Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.',
'["1 <= nums.length <= 2 * 10^4", "-1000 <= nums[i] <= 1000", "-10^7 <= k <= 10^7"]',
'[{"input": {"nums": [1, 1, 1], "k": 2}, "output": 2, "explanation": "Subarrays [1,1] and [1,1] sum to 2."}, {"input": {"nums": [1, 2, 3], "k": 3}, "output": 2, "explanation": "Subarrays [1,2] and [3] sum to 3."}]',
'["array", "hash-table", "prefix-sum"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "Consider what pairs or combinations of numbers could sum to the target.", "LeetCode URL: https://leetcode.com/problems/subarray-sum-equals-k/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(19,
'class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        pass',
'class Solution {
    public int subarraySum(int[] nums, int k) {
        
    }
}',
'class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        
    }
};',
'[{"input": [[1, 1, 1], 2], "expectedOutput": 2}, {"input": [[1, 2, 3], 3], "expectedOutput": 2}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Subarray Sum Equals K
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Subarray Sum Equals K
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Subarray Sum Equals K
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Subarray Sum Equals K

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 20: Maximum Subarray
-- Maximum Subarray (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(20, 1, 'Maximum Subarray', 'medium',
'Given an integer array nums, find the subarray with the largest sum, and return its sum.',
'["1 <= nums.length <= 10^5", "-10^4 <= nums[i] <= 10^4"]',
'[{"input": {"nums": [-2, 1, -3, 4, -1, 2, 1, -5, 4]}, "output": 6, "explanation": "The subarray [4,-1,2,1] has the largest sum 6."}, {"input": {"nums": [1]}, "output": 1, "explanation": "The subarray [1] has the largest sum 1."}]',
'["array", "divide-and-conquer", "dynamic-programming"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/maximum-subarray/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(20,
'class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        pass',
'class Solution {
    public int maxSubArray(int[] nums) {
        
    }
}',
'class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
    }
};',
'[{"input": [[-2, 1, -3, 4, -1, 2, 1, -5, 4]], "expectedOutput": 6}, {"input": [[1]], "expectedOutput": 1}, {"input": [[5, 4, -1, 7, 8]], "expectedOutput": 23}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        Kadane''s Algorithm - Classic dynamic programming approach.
        Finds contiguous subarray with the largest sum.

        Key insight: At each position, we decide whether to:
        - Extend the current subarray (add current element)
        - Start a new subarray (current element alone is better)

        Time Complexity: O(n) - single pass through array
        Space Complexity: O(1) - only tracking two variables
        """
        # Track the maximum sum ending at current position
        current_sum = nums[0]
        # Track the overall maximum sum seen so far
        max_sum = nums[0]

        # Iterate through array starting from second element
        for i in range(1, len(nums)):
            # Decide: extend current subarray or start fresh
            # If current_sum is negative, starting fresh is better
            current_sum = max(nums[i], current_sum + nums[i])

            # Update global maximum
            max_sum = max(max_sum, current_sum)

        return max_sum
',
'// Solution for Maximum Subarray
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Maximum Subarray
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Maximum Subarray

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 21: Remove Nth Node From End of List
-- Remove Nth Node From End of List (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(21, 1, 'Remove Nth Node From End of List', 'medium',
'Given the head of a linked list, remove the nth node from the end of the list and return its head.',
'["The number of nodes in the list is sz", "1 <= sz <= 30", "0 <= Node.val <= 100", "1 <= n <= sz"]',
'[{"input": {"head": [1, 2, 3, 4, 5], "n": 2}, "output": [1, 2, 3, 5], "explanation": "Remove 2nd node from end."}]',
'["linked-list", "two-pointers"]',
'["Try using two pointers - one starting from the beginning and one from the end.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/remove-nth-node-from-end-of-list/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(21,
'class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        
    }
}',
'class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        
    }
};',
'[{"input": [[1, 2, 3, 4, 5], 2], "expectedOutput": [1, 2, 3, 5]}, {"input": [[1], 1], "expectedOutput": []}, {"input": [[1, 2], 1], "expectedOutput": [1]}]',
'[]',
'O(n)',
'O(1)',
'# Solution for Remove Nth Node From End of List
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Remove Nth Node From End of List
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Remove Nth Node From End of List
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Remove Nth Node From End of List

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 22: Reverse Linked List II
-- Reverse Linked List II (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(22, 1, 'Reverse Linked List II', 'medium',
'Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.',
'["The number of nodes in the list is n", "1 <= n <= 500", "-500 <= Node.val <= 500", "1 <= left <= right <= n"]',
'[{"input": {"head": [1, 2, 3, 4, 5], "left": 2, "right": 4}, "output": [1, 4, 3, 2, 5], "explanation": "Reverse nodes from position 2 to 4."}]',
'["linked-list"]',
'["Think about the time and space complexity trade-offs.", "Consider reversing the entire sequence or parts of it.", "LeetCode URL: https://leetcode.com/problems/reverse-linked-list-ii/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(22,
'class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        
    }
}',
'class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        
    }
};',
'[{"input": [[1, 2, 3, 4, 5], 2, 4], "expectedOutput": [1, 4, 3, 2, 5]}, {"input": [[5], 1, 1], "expectedOutput": [5]}]',
'[]',
'O(n)',
'O(1)',
'# Solution for Reverse Linked List II
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Reverse Linked List II
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Reverse Linked List II
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Reverse Linked List II

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 23: Swap Nodes in Pairs
-- Swap Nodes in Pairs (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(23, 1, 'Swap Nodes in Pairs', 'medium',
'Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list''s nodes.',
'["The number of nodes in the list is in the range [0, 100]", "0 <= Node.val <= 100"]',
'[{"input": {"head": [1, 2, 3, 4]}, "output": [2, 1, 4, 3], "explanation": "Swap adjacent pairs."}]',
'["linked-list", "recursion"]',
'["Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/swap-nodes-in-pairs/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(23,
'class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode swapPairs(ListNode head) {
        
    }
}',
'class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        
    }
};',
'[{"input": [[1, 2, 3, 4]], "expectedOutput": [2, 1, 4, 3]}, {"input": [[]], "expectedOutput": []}, {"input": [[1]], "expectedOutput": [1]}]',
'[]',
'O(n)',
'O(1)',
'# Solution for Swap Nodes in Pairs
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Swap Nodes in Pairs
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Swap Nodes in Pairs
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Swap Nodes in Pairs

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 24: Binary Tree Level Order Traversal
-- Binary Tree Level Order Traversal (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(24, 1, 'Binary Tree Level Order Traversal', 'medium',
'Given the root of a binary tree, return the level order traversal of its nodes'' values. (i.e., from left to right, level by level).',
'["The number of nodes in the tree is in the range [0, 2000]", "-1000 <= Node.val <= 1000"]',
'[{"input": {"root": [3, 9, 20, null, null, 15, 7]}, "output": [[3], [9, 20], [15, 7]], "explanation": "Level by level traversal."}]',
'["tree", "breadth-first-search"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/binary-tree-level-order-traversal/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(24,
'class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        pass',
'class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        
    }
}',
'class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        
    }
};',
'[{"input": [[3, 9, 20, null, null, 15, 7]], "expectedOutput": [[3], [9, 20], [15, 7]]}, {"input": [[1]], "expectedOutput": [[1]]}, {"input": [[]], "expectedOutput": []}]',
'[]',
'O(n)',
'O(n)',
'# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        """
        Breadth-First Search (BFS) using a queue.
        Traverses tree level by level, collecting nodes at each level.

        Algorithm:
        1. Use queue to track nodes at current level
        2. For each level, process all nodes and collect their values
        3. Add children of current level to queue for next level

        Time Complexity: O(n) - visit each node once
        Space Complexity: O(w) - where w is maximum width of tree (queue size)
        """
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            current_level = []

            # Process all nodes at current level
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)

                # Add children to queue for next level
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(current_level)

        return result
',
'// Solution for Binary Tree Level Order Traversal
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Binary Tree Level Order Traversal
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Binary Tree Level Order Traversal

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 25: Validate Binary Search Tree
-- Validate Binary Search Tree (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(25, 1, 'Validate Binary Search Tree', 'medium',
'Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node''s key.
- The right subtree of a node contains only nodes with keys greater than the node''s key.
- Both the left and right subtrees must also be binary search trees.',
'["The number of nodes in the tree is in the range [1, 10^4]", "-2^31 <= Node.val <= 2^31 - 1"]',
'[{"input": {"root": [2, 1, 3]}, "output": true, "explanation": "Valid BST."}, {"input": {"root": [5, 1, 4, null, null, 3, 6]}, "output": false, "explanation": "Node 4 in right subtree of 5 violates BST property."}]',
'["tree", "depth-first-search", "binary-search-tree"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "If the data is sorted, binary search can be very efficient.", "LeetCode URL: https://leetcode.com/problems/validate-binary-search-tree/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(25,
'class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        pass',
'class Solution {
    public boolean isValidBST(TreeNode root) {
        
    }
}',
'class Solution {
public:
    bool isValidBST(TreeNode* root) {
        
    }
};',
'[{"input": [[2, 1, 3]], "expectedOutput": true}, {"input": [[5, 1, 4, null, null, 3, 6]], "expectedOutput": false}]',
'[]',
'O(n)',
'O(n)',
'# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        """
        Recursive validation with min/max bounds.
        BST property: all nodes in left subtree < root < all nodes in right subtree

        Algorithm:
        - Track valid range [min_val, max_val] for each node
        - Left child must be < current node value
        - Right child must be > current node value
        - Recursively validate with updated bounds

        Time Complexity: O(n) - visit each node once
        Space Complexity: O(h) - recursion stack where h is tree height
        """
        def validate(node: Optional[TreeNode], min_val: float, max_val: float) -> bool:
            # Empty tree is valid BST
            if not node:
                return True

            # Check if current node violates BST property
            if node.val <= min_val or node.val >= max_val:
                return False

            # Recursively validate left and right subtrees with updated bounds
            # Left subtree: all values must be < node.val
            # Right subtree: all values must be > node.val
            return (validate(node.left, min_val, node.val) and
                    validate(node.right, node.val, max_val))

        # Start with infinite bounds
        return validate(root, float(''-inf''), float(''inf''))
',
'// Solution for Validate Binary Search Tree
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Validate Binary Search Tree
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Validate Binary Search Tree

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 26: Kth Smallest Element in a BST
-- Kth Smallest Element in a BST (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(26, 1, 'Kth Smallest Element in a BST', 'medium',
'Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.',
'["The number of nodes in the tree is n", "1 <= k <= n <= 10^4", "0 <= Node.val <= 10^4"]',
'[{"input": {"root": [3, 1, 4, null, 2], "k": 1}, "output": 1, "explanation": "The smallest element is 1."}, {"input": {"root": [5, 3, 6, 2, 4, null, null, 1], "k": 3}, "output": 3, "explanation": "The 3rd smallest is 3."}]',
'["tree", "depth-first-search", "binary-search-tree"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/kth-smallest-element-in-a-bst/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(26,
'class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        pass',
'class Solution {
    public int kthSmallest(TreeNode root, int k) {
        
    }
}',
'class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        
    }
};',
'[{"input": [[3, 1, 4, null, 2], 1], "expectedOutput": 1}, {"input": [[5, 3, 6, 2, 4, null, null, 1], 3], "expectedOutput": 3}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Kth Smallest Element in a BST
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Kth Smallest Element in a BST
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Kth Smallest Element in a BST
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Kth Smallest Element in a BST

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 27: Binary Tree Right Side View
-- Binary Tree Right Side View (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(27, 1, 'Binary Tree Right Side View', 'medium',
'Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.',
'["The number of nodes in the tree is in the range [0, 100]", "-100 <= Node.val <= 100"]',
'[{"input": {"root": [1, 2, 3, null, 5, null, 4]}, "output": [1, 3, 4], "explanation": "Right side view shows nodes 1, 3, 4."}]',
'["tree", "depth-first-search", "breadth-first-search"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/binary-tree-right-side-view/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(27,
'class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        pass',
'class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        
    }
}',
'class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        
    }
};',
'[{"input": [[1, 2, 3, null, 5, null, 4]], "expectedOutput": [1, 3, 4]}, {"input": [[1, null, 3]], "expectedOutput": [1, 3]}, {"input": [[]], "expectedOutput": []}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Binary Tree Right Side View
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Binary Tree Right Side View
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Binary Tree Right Side View
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Binary Tree Right Side View

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 28: Path Sum II
-- Path Sum II (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(28, 1, 'Path Sum II', 'medium',
'Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.

A root-to-leaf path is a path starting from the root and ending at any leaf node.',
'["The number of nodes in the tree is in the range [0, 5000]", "-1000 <= Node.val <= 1000", "-1000 <= targetSum <= 1000"]',
'[{"input": {"root": [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1], "targetSum": 22}, "output": [[5, 4, 11, 2], [5, 8, 4, 5]], "explanation": "Two paths sum to 22."}]',
'["tree", "backtracking", "depth-first-search"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Try exploring all possibilities using recursion and backtracking.", "Think about the time and space complexity trade-offs.", "Consider what pairs or combinations of numbers could sum to the target.", "LeetCode URL: https://leetcode.com/problems/path-sum-ii/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(28,
'class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        pass',
'class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        
    }
}',
'class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        
    }
};',
'[{"input": [[5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1], 22], "expectedOutput": [[5, 4, 11, 2], [5, 8, 4, 5]]}, {"input": [[1, 2, 3], 5], "expectedOutput": []}, {"input": [[1, 2], 0], "expectedOutput": []}]',
'[]',
'O(n^2)',
'O(n)',
'# Solution for Path Sum II
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Path Sum II
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Path Sum II
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Path Sum II

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 29: Construct Binary Tree from Preorder and Inorder Traversal
-- Construct Binary Tree from Preorder and Inorder Traversal (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(29, 1, 'Construct Binary Tree from Preorder and Inorder Traversal', 'medium',
'Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.',
'["1 <= preorder.length <= 3000", "inorder.length == preorder.length", "-3000 <= preorder[i], inorder[i] <= 3000", "preorder and inorder consist of unique values"]',
'[{"input": {"preorder": [3, 9, 20, 15, 7], "inorder": [9, 3, 15, 20, 7]}, "output": [3, 9, 20, null, null, 15, 7], "explanation": "Construct tree from traversals."}]',
'["tree", "array", "hash-table", "divide-and-conquer"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Think about the array indices and how you can traverse or manipulate them.", "Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(29,
'class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        pass',
'class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        
    }
}',
'class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        
    }
};',
'[{"input": [[3, 9, 20, 15, 7], [9, 3, 15, 20, 7]], "expectedOutput": [3, 9, 20, null, null, 15, 7]}, {"input": [[-1], [-1]], "expectedOutput": [-1]}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Construct Binary Tree from Preorder and Inorder Traversal
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Construct Binary Tree from Preorder and Inorder Traversal
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Construct Binary Tree from Preorder and Inorder Traversal
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Construct Binary Tree from Preorder and Inorder Traversal

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 30: Lowest Common Ancestor of a Binary Tree
-- Lowest Common Ancestor of a Binary Tree (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(30, 1, 'Lowest Common Ancestor of a Binary Tree', 'medium',
'Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

The lowest common ancestor is defined as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself).',
'["The number of nodes in the tree is in the range [2, 10^5]", "-10^9 <= Node.val <= 10^9", "All Node.val are unique", "p != q", "p and q exist in the tree"]',
'[{"input": {"root": [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], "p": 5, "q": 1}, "output": 3, "explanation": "The LCA of nodes 5 and 1 is 3."}]',
'["tree", "depth-first-search", "binary-tree"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(30,
'class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        pass',
'class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
    }
}',
'class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
    }
};',
'[{"input": [[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], 5, 1], "expectedOutput": 3}, {"input": [[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], 5, 4], "expectedOutput": 5}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Lowest Common Ancestor of a Binary Tree
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Lowest Common Ancestor of a Binary Tree
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Lowest Common Ancestor of a Binary Tree
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Lowest Common Ancestor of a Binary Tree

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 31: Number of Islands
-- Number of Islands (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(31, 1, 'Number of Islands', 'medium',
'Given an m x n 2D binary grid which represents a map of ''1''s (land) and ''0''s (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.',
'["m == grid.length", "n == grid[i].length", "1 <= m, n <= 300", "grid[i][j] is ''0'' or ''1''"]',
'[{"input": {"grid": [["1", "1", "1", "1", "0"], ["1", "1", "0", "1", "0"], ["1", "1", "0", "0", "0"], ["0", "0", "0", "0", "0"]]}, "output": 1, "explanation": "One connected island."}]',
'["array", "depth-first-search", "breadth-first-search", "union-find", "matrix"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/number-of-islands/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(31,
'class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        pass',
'class Solution {
    public int numIslands(char[][] grid) {
        
    }
}',
'class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        
    }
};',
'[{"input": [[["1", "1", "1", "1", "0"], ["1", "1", "0", "1", "0"], ["1", "1", "0", "0", "0"], ["0", "0", "0", "0", "0"]]], "expectedOutput": 1}, {"input": [[["1", "1", "0", "0", "0"], ["1", "1", "0", "0", "0"], ["0", "0", "1", "0", "0"], ["0", "0", "0", "1", "1"]]], "expectedOutput": 3}]',
'[]',
'O(m*n)',
'O(m*n)',
'class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        """
        Depth-First Search (DFS) to find connected components.
        Each island is a connected component of ''1''s (land).

        Algorithm:
        1. Iterate through each cell in grid
        2. When we find unvisited land (''1''), it''s a new island
        3. DFS from that cell to mark all connected land as visited
        4. Count total number of DFS calls (number of islands)

        Time Complexity: O(m * n) - visit each cell at most twice
        Space Complexity: O(m * n) - worst case recursion depth (all land)
        """
        if not grid or not grid[0]:
            return 0

        rows, cols = len(grid), len(grid[0])
        num_islands = 0

        def dfs(r: int, c: int) -> None:
            """Mark all connected land cells as visited."""
            # Base cases: out of bounds or water or already visited
            if (r < 0 or r >= rows or c < 0 or c >= cols or
                grid[r][c] != ''1''):
                return

            # Mark current cell as visited by changing to ''0''
            grid[r][c] = ''0''

            # Explore all 4 directions (up, down, left, right)
            dfs(r + 1, c)  # down
            dfs(r - 1, c)  # up
            dfs(r, c + 1)  # right
            dfs(r, c - 1)  # left

        # Scan entire grid
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == ''1'':
                    # Found new island
                    num_islands += 1
                    # Mark all connected land
                    dfs(r, c)

        return num_islands
',
'// Solution for Number of Islands
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Number of Islands
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Number of Islands

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 32: Course Schedule
-- Course Schedule (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(32, 1, 'Course Schedule', 'medium',
'There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

Return True if you can finish all courses. Otherwise, return False.',
'["1 <= numCourses <= 2000", "0 <= prerequisites.length <= 5000", "prerequisites[i].length == 2", "0 <= ai, bi < numCourses", "All the pairs prerequisites[i] are unique"]',
'[{"input": {"numCourses": 2, "prerequisites": [[1, 0]]}, "output": true, "explanation": "Take course 0 first, then course 1."}, {"input": {"numCourses": 2, "prerequisites": [[1, 0], [0, 1]]}, "output": false, "explanation": "Circular dependency."}]',
'["graph", "topological-sort", "depth-first-search", "breadth-first-search"]',
'["Consider graph traversal algorithms like DFS or BFS.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/course-schedule/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(32,
'class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        pass',
'class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        
    }
}',
'class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        
    }
};',
'[{"input": [2, [[1, 0]]], "expectedOutput": true}, {"input": [2, [[1, 0], [0, 1]]], "expectedOutput": false}]',
'[]',
'O(V+E)',
'O(V+E)',
'class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        """
        Topological Sort using DFS to detect cycles.
        Check if course schedule is possible (no circular dependencies).

        Algorithm:
        1. Build adjacency list (prerequisite graph)
        2. Use DFS with state tracking:
           - UNVISITED (0): not processed
           - VISITING (1): currently in DFS path (cycle if revisited)
           - VISITED (2): fully processed
        3. If we encounter VISITING node, there''s a cycle

        Time Complexity: O(V + E) - vertices (courses) + edges (prerequisites)
        Space Complexity: O(V + E) - graph storage + recursion stack
        """
        from collections import defaultdict

        # Build adjacency list: course -> list of courses that depend on it
        graph = defaultdict(list)
        for course, prereq in prerequisites:
            graph[prereq].append(course)

        # State: 0=unvisited, 1=visiting (in current DFS path), 2=visited
        state = [0] * numCourses

        def has_cycle(course: int) -> bool:
            """DFS to detect cycle. Returns True if cycle found."""
            if state[course] == 1:
                # Currently visiting - found cycle
                return True
            if state[course] == 2:
                # Already fully processed - no cycle through this path
                return False

            # Mark as visiting (in current DFS path)
            state[course] = 1

            # Check all courses that depend on this one
            for next_course in graph[course]:
                if has_cycle(next_course):
                    return True

            # Mark as visited (fully processed)
            state[course] = 2
            return False

        # Check each course for cycles
        for course in range(numCourses):
            if state[course] == 0:  # Unvisited
                if has_cycle(course):
                    return False

        return True
',
'// Solution for Course Schedule
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Course Schedule
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Course Schedule

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 33: Clone Graph
-- Clone Graph (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(33, 1, 'Clone Graph', 'medium',
'Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.',
'["The number of nodes in the graph is in the range [0, 100]", "1 <= Node.val <= 100", "Node.val is unique for each node", "There are no repeated edges and no self-loops"]',
'[{"input": {"adjList": [[2, 4], [1, 3], [2, 4], [1, 3]]}, "output": [[2, 4], [1, 3], [2, 4], [1, 3]], "explanation": "Clone the graph."}]',
'["hash-table", "depth-first-search", "breadth-first-search", "graph"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Consider graph traversal algorithms like DFS or BFS.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/clone-graph/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(33,
'class Solution:
    def cloneGraph(self, node: Optional[''Node'']) -> Optional[''Node'']:
        pass',
'class Solution {
    public Node cloneGraph(Node node) {
        
    }
}',
'class Solution {
public:
    Node* cloneGraph(Node* node) {
        
    }
};',
'[{"input": [[[2, 4], [1, 3], [2, 4], [1, 3]]], "expectedOutput": [[2, 4], [1, 3], [2, 4], [1, 3]]}, {"input": [[[]]], "expectedOutput": [[]]}, {"input": [[]], "expectedOutput": []}]',
'[]',
'O(N+M)',
'O(N)',
'"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def cloneGraph(self, node: ''Node'') -> ''Node'':
        """
        Deep copy graph using DFS with hash map.
        Creates independent copy where no node is shared with original.

        Algorithm:
        1. Use hash map to track original node -> cloned node mapping
        2. DFS through graph:
           - Clone current node if not already cloned
           - Recursively clone all neighbors
           - Connect cloned node to cloned neighbors

        Time Complexity: O(V + E) - visit each vertex and edge once
        Space Complexity: O(V) - hash map + recursion stack
        """
        if not node:
            return None

        # Map: original node -> cloned node
        cloned = {}

        def dfs(original: ''Node'') -> ''Node'':
            """Recursively clone node and its neighbors."""
            # If already cloned, return the clone
            if original in cloned:
                return cloned[original]

            # Create clone of current node (without neighbors yet)
            clone = Node(original.val)
            cloned[original] = clone

            # Recursively clone all neighbors and connect them
            for neighbor in original.neighbors:
                clone.neighbors.append(dfs(neighbor))

            return clone

        return dfs(node)
',
'// Solution for Clone Graph
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Clone Graph
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Clone Graph

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 34: Word Search
-- Word Search (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(34, 1, 'Word Search', 'medium',
'Given an m x n grid of characters board and a string word, return True if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.',
'["m == board.length", "n = board[i].length", "1 <= m, n <= 6", "1 <= word.length <= 15", "board and word consists of only lowercase and uppercase English letters"]',
'[{"input": {"board": [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], "word": "ABCCED"}, "output": true, "explanation": "Word found in board."}]',
'["array", "backtracking", "matrix"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Try exploring all possibilities using recursion and backtracking.", "Think about the time and space complexity trade-offs.", "If the data is sorted, binary search can be very efficient.", "LeetCode URL: https://leetcode.com/problems/word-search/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(34,
'class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        pass',
'class Solution {
    public boolean exist(char[][] board, String word) {
        
    }
}',
'class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        
    }
};',
'[{"input": [[["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], "ABCCED"], "expectedOutput": true}, {"input": [[["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], "SEE"], "expectedOutput": true}, {"input": [[["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], "ABCB"], "expectedOutput": false}]',
'[]',
'O(m*n*4^L)',
'O(L)',
'# Solution for Word Search
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Word Search
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Word Search
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Word Search

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 35: Coin Change
-- Coin Change (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(35, 1, 'Coin Change', 'medium',
'You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.',
'["1 <= coins.length <= 12", "1 <= coins[i] <= 2^31 - 1", "0 <= amount <= 10^4"]',
'[{"input": {"coins": [1, 2, 5], "amount": 11}, "output": 3, "explanation": "11 = 5 + 5 + 1"}, {"input": {"coins": [2], "amount": 3}, "output": -1, "explanation": "Cannot make amount 3."}]',
'["array", "dynamic-programming", "breadth-first-search"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/coin-change/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(35,
'class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        pass',
'class Solution {
    public int coinChange(int[] coins, int amount) {
        
    }
}',
'class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        
    }
};',
'[{"input": [[1, 2, 5], 11], "expectedOutput": 3}, {"input": [[2], 3], "expectedOutput": -1}, {"input": [[1], 0], "expectedOutput": 0}]',
'[]',
'O(amount * n)',
'O(amount)',
'class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        """
        Bottom-up Dynamic Programming approach.
        Find minimum number of coins needed to make up the target amount.

        Algorithm:
        1. Create DP array where dp[i] = min coins needed for amount i
        2. Initialize dp[0] = 0 (zero coins for amount 0)
        3. For each amount from 1 to target:
           - Try each coin denomination
           - Take minimum of all valid options

        Time Complexity: O(amount * len(coins))
        Space Complexity: O(amount) - DP array
        """
        # Initialize DP array with infinity (impossible to make)
        # dp[i] represents min coins needed to make amount i
        dp = [float(''inf'')] * (amount + 1)
        dp[0] = 0  # Base case: 0 coins for amount 0

        # Build up solution for each amount from 1 to target
        for current_amount in range(1, amount + 1):
            # Try each coin denomination
            for coin in coins:
                if coin <= current_amount:
                    # If we can use this coin, check if it gives better solution
                    # dp[current_amount - coin] + 1 means:
                    # "min coins for (current_amount - coin)" + this coin
                    dp[current_amount] = min(
                        dp[current_amount],
                        dp[current_amount - coin] + 1
                    )

        # If dp[amount] is still infinity, amount cannot be made
        return dp[amount] if dp[amount] != float(''inf'') else -1
',
'// Solution for Coin Change
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Coin Change
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Coin Change

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 36: Longest Increasing Subsequence
-- Longest Increasing Subsequence (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(36, 1, 'Longest Increasing Subsequence', 'medium',
'Given an integer array nums, return the length of the longest strictly increasing subsequence.',
'["1 <= nums.length <= 2500", "-10^4 <= nums[i] <= 10^4"]',
'[{"input": {"nums": [10, 9, 2, 5, 3, 7, 101, 18]}, "output": 4, "explanation": "The longest increasing subsequence is [2,3,7,101]."}, {"input": {"nums": [0, 1, 0, 3, 2, 3]}, "output": 4, "explanation": "The longest increasing subsequence is [0,1,2,3]."}]',
'["array", "binary-search", "dynamic-programming"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "If the input is sorted, binary search can achieve O(log n) time complexity.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/longest-increasing-subsequence/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(36,
'class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        pass',
'class Solution {
    public int lengthOfLIS(int[] nums) {
        
    }
}',
'class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        
    }
};',
'[{"input": [[10, 9, 2, 5, 3, 7, 101, 18]], "expectedOutput": 4}, {"input": [[0, 1, 0, 3, 2, 3]], "expectedOutput": 4}, {"input": [[7, 7, 7, 7, 7, 7, 7]], "expectedOutput": 1}]',
'[]',
'O(n^2)',
'O(n)',
'class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        """
        Dynamic Programming with Binary Search optimization.
        Finds length of longest strictly increasing subsequence.

        Algorithm (Patience Sort approach):
        1. Maintain array ''sub'' of smallest tail values for increasing subsequences
        2. For each number, binary search for position in ''sub''
        3. If larger than all elements, extend subsequence
        4. Otherwise, replace first element >= current number

        Why this works: We''re maintaining optimal tails for all subsequence lengths.

        Time Complexity: O(n log n) - binary search for each element
        Space Complexity: O(n) - sub array
        """
        if not nums:
            return 0

        # sub[i] = smallest tail element for increasing subsequence of length i+1
        sub = []

        for num in nums:
            # Binary search for position to insert/replace
            left, right = 0, len(sub)

            while left < right:
                mid = (left + right) // 2
                if sub[mid] < num:
                    left = mid + 1
                else:
                    right = mid

            # If num is larger than all elements in sub, extend subsequence
            if left == len(sub):
                sub.append(num)
            else:
                # Replace first element >= num to keep smallest possible tail
                sub[left] = num

        return len(sub)
',
'// Solution for Longest Increasing Subsequence
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Longest Increasing Subsequence
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Longest Increasing Subsequence

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 37: Unique Paths
-- Unique Paths (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(37, 1, 'Unique Paths', 'medium',
'There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.',
'["1 <= m, n <= 100"]',
'[{"input": {"m": 3, "n": 7}, "output": 28, "explanation": "There are 28 unique paths."}, {"input": {"m": 3, "n": 2}, "output": 3, "explanation": "From top-left: right->down->down, down->down->right, down->right->down"}]',
'["math", "dynamic-programming", "combinatorics"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/unique-paths/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(37,
'class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        pass',
'class Solution {
    public int uniquePaths(int m, int n) {
        
    }
}',
'class Solution {
public:
    int uniquePaths(int m, int n) {
        
    }
};',
'[{"input": [3, 7], "expectedOutput": 28}, {"input": [3, 2], "expectedOutput": 3}]',
'[]',
'O(m*n)',
'O(m*n)',
'# Solution for Unique Paths
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Unique Paths
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Unique Paths
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Unique Paths

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 38: Word Break
-- Word Break (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(38, 1, 'Word Break', 'medium',
'Given a string s and a dictionary of strings wordDict, return True if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.',
'["1 <= s.length <= 300", "1 <= wordDict.length <= 1000", "1 <= wordDict[i].length <= 20", "s and wordDict[i] consist of only lowercase English letters", "All strings in wordDict are unique"]',
'[{"input": {"s": "leetcode", "wordDict": ["leet", "code"]}, "output": true, "explanation": "''leetcode'' can be segmented as ''leet code''."}, {"input": {"s": "applepenapple", "wordDict": ["apple", "pen"]}, "output": true, "explanation": "''applepenapple'' can be segmented as ''apple pen apple''."}]',
'["hash-table", "string", "dynamic-programming", "trie", "memoization"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/word-break/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(38,
'class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        pass',
'class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        
    }
}',
'class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        
    }
};',
'[{"input": ["leetcode", ["leet", "code"]], "expectedOutput": true}, {"input": ["applepenapple", ["apple", "pen"]], "expectedOutput": true}, {"input": ["catsandog", ["cats", "dog", "sand", "and", "cat"]], "expectedOutput": false}]',
'[]',
'O(n^2)',
'O(n)',
'# Solution for Word Break
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Word Break
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Word Break
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Word Break

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 39: House Robber II
-- House Robber II (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(39, 1, 'House Robber II', 'medium',
'You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.',
'["1 <= nums.length <= 100", "0 <= nums[i] <= 1000"]',
'[{"input": {"nums": [2, 3, 2]}, "output": 3, "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent."}, {"input": {"nums": [1, 2, 3, 1]}, "output": 4, "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4."}]',
'["array", "dynamic-programming"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/house-robber-ii/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(39,
'class Solution:
    def rob(self, nums: List[int]) -> int:
        pass',
'class Solution {
    public int rob(int[] nums) {
        
    }
}',
'class Solution {
public:
    int rob(vector<int>& nums) {
        
    }
};',
'[{"input": [[2, 3, 2]], "expectedOutput": 3}, {"input": [[1, 2, 3, 1]], "expectedOutput": 4}, {"input": [[1, 2, 3]], "expectedOutput": 3}]',
'[]',
'O(n)',
'O(1)',
'# Solution for House Robber II
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for House Robber II
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for House Robber II
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for House Robber II

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 40: Decode Ways
-- Decode Ways (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(40, 1, 'Decode Ways', 'medium',
'A message containing letters from A-Z can be encoded into numbers using the following mapping:
''A'' -> "1", ''B'' -> "2", ..., ''Z'' -> "26"

To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above. Given a string s containing only digits, return the number of ways to decode it.',
'["1 <= s.length <= 100", "s contains only digits and may contain leading zero(s)"]',
'[{"input": {"s": "12"}, "output": 2, "explanation": "It could be decoded as ''AB'' (1 2) or ''L'' (12)."}, {"input": {"s": "226"}, "output": 3, "explanation": "It could be decoded as ''BZ'' (2 26), ''VF'' (22 6), or ''BBF'' (2 2 6)."}]',
'["string", "dynamic-programming"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/decode-ways/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(40,
'class Solution:
    def numDecodings(self, s: str) -> int:
        pass',
'class Solution {
    public int numDecodings(String s) {
        
    }
}',
'class Solution {
public:
    int numDecodings(string s) {
        
    }
};',
'[{"input": ["12"], "expectedOutput": 2}, {"input": ["226"], "expectedOutput": 3}, {"input": ["06"], "expectedOutput": 0}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Decode Ways
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Decode Ways
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Decode Ways
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Decode Ways

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 41: Letter Combinations of a Phone Number
-- Letter Combinations of a Phone Number (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(41, 1, 'Letter Combinations of a Phone Number', 'medium',
'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

2: abc, 3: def, 4: ghi, 5: jkl, 6: mno, 7: pqrs, 8: tuv, 9: wxyz',
'["0 <= digits.length <= 4", "digits[i] is a digit in the range [''2'', ''9'']"]',
'[{"input": {"digits": "23"}, "output": ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"], "explanation": "All possible combinations."}, {"input": {"digits": ""}, "output": [], "explanation": "Empty input."}]',
'["hash-table", "string", "backtracking"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Try exploring all possibilities using recursion and backtracking.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/letter-combinations-of-a-phone-number/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(41,
'class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        pass',
'class Solution {
    public List<String> letterCombinations(String digits) {
        
    }
}',
'class Solution {
public:
    vector<string> letterCombinations(string digits) {
        
    }
};',
'[{"input": ["23"], "expectedOutput": ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]}, {"input": [""], "expectedOutput": []}, {"input": ["2"], "expectedOutput": ["a", "b", "c"]}]',
'[]',
'O(4^n)',
'O(n)',
'# Solution for Letter Combinations of a Phone Number
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Letter Combinations of a Phone Number
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Letter Combinations of a Phone Number
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Letter Combinations of a Phone Number

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 42: Generate Parentheses
-- Generate Parentheses (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(42, 1, 'Generate Parentheses', 'medium',
'Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.',
'["1 <= n <= 8"]',
'[{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"], "explanation": "All valid combinations of 3 pairs."}, {"input": {"n": 1}, "output": ["()"], "explanation": "Only one combination."}]',
'["string", "dynamic-programming", "backtracking"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Try exploring all possibilities using recursion and backtracking.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "Think about the time and space complexity trade-offs.", "Track opening and closing brackets, ensuring they match correctly.", "LeetCode URL: https://leetcode.com/problems/generate-parentheses/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(42,
'class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        pass',
'class Solution {
    public List<String> generateParenthesis(int n) {
        
    }
}',
'class Solution {
public:
    vector<string> generateParenthesis(int n) {
        
    }
};',
'[{"input": [3], "expectedOutput": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": [1], "expectedOutput": ["()"]}]',
'[]',
'O(4^n/sqrt(n))',
'O(n)',
'# Solution for Generate Parentheses
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Generate Parentheses
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Generate Parentheses
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Generate Parentheses

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 43: Permutations
-- Permutations (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(43, 1, 'Permutations', 'medium',
'Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.',
'["1 <= nums.length <= 6", "-10 <= nums[i] <= 10", "All the integers of nums are unique"]',
'[{"input": {"nums": [1, 2, 3]}, "output": [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]], "explanation": "All permutations."}, {"input": {"nums": [0, 1]}, "output": [[0, 1], [1, 0]], "explanation": "Two permutations."}]',
'["array", "backtracking"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Try exploring all possibilities using recursion and backtracking.", "Think about the time and space complexity trade-offs.", "LeetCode URL: https://leetcode.com/problems/permutations/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(43,
'class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        pass',
'class Solution {
    public List<List<Integer>> permute(int[] nums) {
        
    }
}',
'class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        
    }
};',
'[{"input": [[1, 2, 3]], "expectedOutput": [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]}, {"input": [[0, 1]], "expectedOutput": [[0, 1], [1, 0]]}, {"input": [[1]], "expectedOutput": [[1]]}]',
'[]',
'O(n!)',
'O(n)',
'# Solution for Permutations
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Permutations
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Permutations
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Permutations

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 44: Trapping Rain Water
-- Trapping Rain Water (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(44, 1, 'Trapping Rain Water', 'hard',
'Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.',
'["n == height.length", "1 <= n <= 2 * 10^4", "0 <= height[i] <= 10^5"]',
'[{"input": {"height": [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]}, "output": 6, "explanation": "The elevation map can trap 6 units of rain water."}]',
'["array", "two-pointers", "dynamic-programming", "stack", "monotonic-stack"]',
'["Think about the array indices and how you can traverse or manipulate them.", "Try using two pointers - one starting from the beginning and one from the end.", "A stack data structure (LIFO) might be useful here.", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/trapping-rain-water/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(44,
'class Solution:
    def trap(self, height: List[int]) -> int:
        pass',
'class Solution {
    public int trap(int[] height) {
        
    }
}',
'class Solution {
public:
    int trap(vector<int>& height) {
        
    }
};',
'[{"input": [[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]], "expectedOutput": 6}, {"input": [[4, 2, 0, 3, 2, 5]], "expectedOutput": 9}]',
'[]',
'O(n)',
'O(1)',
'class Solution:
    def trap(self, height: List[int]) -> int:
        """
        Two-pointer technique to calculate trapped water.
        Water level at position i = min(max_left[i], max_right[i]) - height[i]

        Algorithm:
        Use two pointers moving inward, tracking max heights from both sides:
        1. Start with left and right pointers at edges
        2. Move pointer with smaller max height inward
        3. Calculate water trapped based on current max heights
        4. Key insight: water trapped depends on the SMALLER of left/right max

        Time Complexity: O(n) - single pass with two pointers
        Space Complexity: O(1) - only using pointers and max trackers
        """
        if not height:
            return 0

        left, right = 0, len(height) - 1
        left_max, right_max = 0, 0
        water = 0

        while left < right:
            if height[left] < height[right]:
                # Process left side
                if height[left] >= left_max:
                    # Update left max
                    left_max = height[left]
                else:
                    # Water trapped = left_max - current height
                    water += left_max - height[left]
                left += 1
            else:
                # Process right side
                if height[right] >= right_max:
                    # Update right max
                    right_max = height[right]
                else:
                    # Water trapped = right_max - current height
                    water += right_max - height[right]
                right -= 1

        return water
',
'// Solution for Trapping Rain Water
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Trapping Rain Water
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Trapping Rain Water

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 45: Median of Two Sorted Arrays
-- Median of Two Sorted Arrays (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(45, 1, 'Median of Two Sorted Arrays', 'hard',
'Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).',
'["nums1.length == m", "nums2.length == n", "0 <= m <= 1000", "0 <= n <= 1000", "1 <= m + n <= 2000", "-10^6 <= nums1[i], nums2[i] <= 10^6"]',
'[{"input": {"nums1": [1, 3], "nums2": [2]}, "output": 2.0, "explanation": "Merged array = [1,2,3], median = 2."}, {"input": {"nums1": [1, 2], "nums2": [3, 4]}, "output": 2.5, "explanation": "Merged array = [1,2,3,4], median = (2+3)/2 = 2.5."}]',
'["array", "binary-search", "divide-and-conquer"]',
'["Think about the array indices and how you can traverse or manipulate them.", "If the input is sorted, binary search can achieve O(log n) time complexity.", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/median-of-two-sorted-arrays/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(45,
'class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        pass',
'class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        
    }
}',
'class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        
    }
};',
'[{"input": [[1, 3], [2]], "expectedOutput": 2.0}, {"input": [[1, 2], [3, 4]], "expectedOutput": 2.5}]',
'[]',
'O(log(min(m,n)))',
'O(1)',
'# Solution for Median of Two Sorted Arrays
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Median of Two Sorted Arrays
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Median of Two Sorted Arrays
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Median of Two Sorted Arrays

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 46: Binary Tree Maximum Path Sum
-- Binary Tree Maximum Path Sum (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(46, 1, 'Binary Tree Maximum Path Sum', 'hard',
'A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node''s values in the path.

Given the root of a binary tree, return the maximum path sum of any non-empty path.',
'["The number of nodes in the tree is in the range [1, 3 * 10^4]", "-1000 <= Node.val <= 1000"]',
'[{"input": {"root": [1, 2, 3]}, "output": 6, "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."}, {"input": {"root": [-10, 9, 20, null, null, 15, 7]}, "output": 42, "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."}]',
'["tree", "depth-first-search", "dynamic-programming", "binary-tree"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Break down the problem into smaller subproblems. What''s the optimal substructure?", "This is a challenging problem. Break it down into smaller parts.", "Consider what pairs or combinations of numbers could sum to the target.", "LeetCode URL: https://leetcode.com/problems/binary-tree-maximum-path-sum/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(46,
'class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        pass',
'class Solution {
    public int maxPathSum(TreeNode root) {
        
    }
}',
'class Solution {
public:
    int maxPathSum(TreeNode* root) {
        
    }
};',
'[{"input": [[1, 2, 3]], "expectedOutput": 6}, {"input": [[-10, 9, 20, null, null, 15, 7]], "expectedOutput": 42}]',
'[]',
'O(n)',
'O(h)',
'# Solution for Binary Tree Maximum Path Sum
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Binary Tree Maximum Path Sum
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Binary Tree Maximum Path Sum
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Binary Tree Maximum Path Sum

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 47: Serialize and Deserialize Binary Tree
-- Serialize and Deserialize Binary Tree (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(47, 1, 'Serialize and Deserialize Binary Tree', 'hard',
'Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.',
'["The number of nodes in the tree is in the range [0, 10^4]", "-1000 <= Node.val <= 1000"]',
'[{"input": {"root": [1, 2, 3, null, null, 4, 5]}, "output": [1, 2, 3, null, null, 4, 5], "explanation": "Serialize then deserialize the tree."}]',
'["string", "tree", "depth-first-search", "breadth-first-search", "design", "binary-tree"]',
'["Think about tree traversal: DFS (depth-first) or BFS (breadth-first).", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(47,
'class Codec:
    def serialize(self, root: Optional[TreeNode]) -> str:
        pass
    
    def deserialize(self, data: str) -> Optional[TreeNode]:
        pass',
'public class Codec {
    public String serialize(TreeNode root) {
        
    }
    
    public TreeNode deserialize(String data) {
        
    }
}',
'class Codec {
public:
    string serialize(TreeNode* root) {
        
    }
    
    TreeNode* deserialize(string data) {
        
    }
};',
'[{"input": [[1, 2, 3, null, null, 4, 5]], "expectedOutput": [1, 2, 3, null, null, 4, 5]}, {"input": [[]], "expectedOutput": []}]',
'[]',
'O(n)',
'O(n)',
'# Solution for Serialize and Deserialize Binary Tree
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Serialize and Deserialize Binary Tree
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Serialize and Deserialize Binary Tree
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Serialize and Deserialize Binary Tree

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 48: Regular Expression Matching
-- Regular Expression Matching (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(48, 1, 'Regular Expression Matching', 'hard',
'Given an input string s and a pattern p, implement regular expression matching with support for ''.'' and ''*'' where:

''.'' Matches any single character.
''*'' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).',
'["1 <= s.length <= 20", "1 <= p.length <= 20", "s contains only lowercase English letters", "p contains only lowercase English letters, ''.'', and ''*''"]',
'[{"input": {"s": "aa", "p": "a"}, "output": false, "explanation": "a does not match the entire string aa."}, {"input": {"s": "aa", "p": "a*"}, "output": true, "explanation": "* means zero or more of the preceding element, a. Therefore, by repeating a once, it becomes aa."}]',
'["string", "dynamic-programming", "recursion"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/regular-expression-matching/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(48,
'class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        pass',
'class Solution {
    public boolean isMatch(String s, String p) {
        
    }
}',
'class Solution {
public:
    bool isMatch(string s, string p) {
        
    }
};',
'[{"input": ["aa", "a"], "expectedOutput": false}, {"input": ["aa", "a*"], "expectedOutput": true}, {"input": ["ab", ".*"], "expectedOutput": true}]',
'[]',
'O(m*n)',
'O(m*n)',
'# Solution for Regular Expression Matching
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Regular Expression Matching
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Regular Expression Matching
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Regular Expression Matching

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 49: Edit Distance
-- Edit Distance (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(49, 1, 'Edit Distance', 'hard',
'Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

You have the following three operations permitted on a word:
- Insert a character
- Delete a character
- Replace a character',
'["0 <= word1.length, word2.length <= 500", "word1 and word2 consist of lowercase English letters"]',
'[{"input": {"word1": "horse", "word2": "ros"}, "output": 3, "explanation": "horse -> rorse (replace ''h'' with ''r'') -> rose (remove ''r'') -> ros (remove ''e'')"}, {"input": {"word1": "intention", "word2": "execution"}, "output": 5, "explanation": "intention -> inention (remove ''t'') -> enention (replace ''i'' with ''e'') -> exention (replace ''n'' with ''x'') -> exection (replace ''n'' with ''c'') -> execution (insert ''u'')"}]',
'["string", "dynamic-programming"]',
'["Break down the problem into smaller subproblems. What''s the optimal substructure?", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/edit-distance/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(49,
'class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        pass',
'class Solution {
    public int minDistance(String word1, String word2) {
        
    }
}',
'class Solution {
public:
    int minDistance(string word1, string word2) {
        
    }
};',
'[{"input": ["horse", "ros"], "expectedOutput": 3}, {"input": ["intention", "execution"], "expectedOutput": 5}]',
'[]',
'O(m*n)',
'O(m*n)',
'# Solution for Edit Distance
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Edit Distance
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Edit Distance
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Edit Distance

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 50: Word Ladder
-- Word Ladder (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(50, 1, 'Word Ladder', 'hard',
'A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
- Every adjacent pair of words differs by a single letter.
- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
- sk == endWord

Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.',
'["1 <= beginWord.length <= 10", "endWord.length == beginWord.length", "1 <= wordList.length <= 5000", "wordList[i].length == beginWord.length", "All strings consist of lowercase English letters", "beginWord != endWord", "All the words in wordList are unique"]',
'[{"input": {"beginWord": "hit", "endWord": "cog", "wordList": ["hot", "dot", "dog", "lot", "log", "cog"]}, "output": 5, "explanation": "One shortest transformation sequence is ''hit'' -> ''hot'' -> ''dot'' -> ''dog'' -> ''cog'', which is 5 words long."}, {"input": {"beginWord": "hit", "endWord": "cog", "wordList": ["hot", "dot", "dog", "lot", "log"]}, "output": 0, "explanation": "The endWord ''cog'' is not in wordList, therefore there is no valid transformation sequence."}]',
'["hash-table", "string", "breadth-first-search"]',
'["Consider using a hash map or dictionary to store and look up values efficiently.", "Consider string manipulation techniques like concatenation, slicing, or pattern matching.", "This is a challenging problem. Break it down into smaller parts.", "LeetCode URL: https://leetcode.com/problems/word-ladder/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(50,
'class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        pass',
'class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
    }
}',
'class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
    }
};',
'[{"input": ["hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"]], "expectedOutput": 5}, {"input": ["hit", "cog", ["hot", "dot", "dog", "lot", "log"]], "expectedOutput": 0}]',
'[]',
'O(M^2 * N)',
'O(M^2 * N)',
'# Solution for Word Ladder
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Word Ladder
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Word Ladder
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Word Ladder

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');


-- Question 51: Merge k Sorted Lists
-- Merge k Sorted Lists (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, constraints, examples, tags, hints) VALUES
(51, 1, 'Merge k Sorted Lists', 'hard',
'You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.',
'["k == lists.length", "0 <= k <= 10^4", "0 <= lists[i].length <= 500", "-10^4 <= lists[i][j] <= 10^4", "lists[i] is sorted in ascending order", "The sum of lists[i].length will not exceed 10^4"]',
'[{"input": {"lists": [[1, 4, 5], [1, 3, 4], [2, 6]]}, "output": [1, 1, 2, 3, 4, 4, 5, 6], "explanation": "Merging all lists: [1,4,5], [1,3,4], and [2,6] into one sorted list."}, {"input": {"lists": []}, "output": [], "explanation": "Empty input."}, {"input": {"lists": [[]]}, "output": [], "explanation": "Single empty list."}]',
'["linked-list", "divide-and-conquer", "heap", "merge-sort"]',
'["This is a challenging problem. Break it down into smaller parts.", "Think about how to combine two sorted sequences efficiently.", "LeetCode URL: https://leetcode.com/problems/merge-k-sorted-lists/"]');

INSERT INTO leetcode_questions (question_id, function_signature_python, function_signature_java, function_signature_cpp, test_cases, hidden_test_cases, expected_time_complexity, expected_space_complexity, solution_python, solution_java, solution_cpp, solution_explanation) VALUES
(51,
'class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        pass',
'class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        
    }
}',
'class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        
    }
};',
'[{"input": [[[1, 4, 5], [1, 3, 4], [2, 6]]], "expectedOutput": [1, 1, 2, 3, 4, 4, 5, 6]}, {"input": [[]], "expectedOutput": []}, {"input": [[[]]], "expectedOutput": []}]',
'[]',
'O(N log k) where N is total number of nodes',
'O(k) for heap or O(log k) for divide-and-conquer',
'# Solution for Merge k Sorted Lists
# Implement the optimal algorithm here
class Solution:
    def solve(self, input):
        # TODO: Implement solution
        pass',
'// Solution for Merge k Sorted Lists
class Solution {
    public returnType solve(inputType input) {
        // TODO: Implement solution
        return None;
    }
}',
'// Solution for Merge k Sorted Lists
class Solution {
public:
    returnType solve(inputType input) {
        // TODO: Implement solution
        return {};
    }
};',
'## Solution for Merge k Sorted Lists

### Approach
Optimal approach based on problem type

### Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)');



-- ============================================
-- ML SYSTEM DESIGN QUESTIONS
-- ============================================

-- Question 52: Design Facebook News Feed Ranking System
-- Design Facebook News Feed Ranking System (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(52, 2, 'Design Facebook News Feed Ranking System', 'hard',
'Design the ML ranking system for Facebook''s News Feed that serves 3B+ users, deciding which posts to show and in what order to maximize meaningful user engagement.',
'["ranking", "multi-task-learning", "news-feed", "meta", "scale", "personalization"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(52,
'Facebook''s News Feed is the core product serving 3B+ users daily. The ML system must:
- Rank posts from friends, pages, groups, and ads
- Process millions of candidate posts per user
- Predict multiple engagement types (likes, comments, shares, time spent, hide/report)
- Optimize for "meaningful social interactions" not just clicks
- Handle diverse content types (text, photo, video, link, live)
- Serve feeds in <500ms while making complex ML predictions
- Combat engagement bait, clickbait, and misinformation
- Balance organic content with ads (revenue optimization)

The system processes billions of posts daily, makes trillions of predictions, and directly impacts Meta''s $100B+ revenue.',
'["Rank feeds for 3B+ users in real-time (<500ms latency)", "Multi-task prediction: likes, comments, shares, time spent, hide", "Multi-objective optimization (engagement + quality + revenue)", "Handle multiple content types with different engagement patterns", "Lightweight models for edge devices (mobile)", "Feature freshness (recent interactions matter)", "Virality modeling (predict shares/spread)", "Counter-abuse: clickbait, engagement bait, misinformation", "Personalization at scale with privacy constraints", "Seamless A/B testing infrastructure"]',
'{"architecture": "Two-stage: candidate generation + heavy ranking", "model_design": "Multi-task learning for different engagement types", "feature_engineering": "User features, post features, social graph, temporal", "training_pipeline": "Distributed training, online learning", "serving_infra": "Low-latency prediction serving at scale", "multi_objective": "Balancing engagement, quality, revenue, user satisfaction", "counter_abuse": "Strategies to detect and demote low-quality content", "evaluation": "Online metrics (time spent, DAU), offline metrics (AUC, calibration)"}',
'["Candidate Generation (filter from millions to thousands)", "Heavy Ranker (GBDT or Deep Neural Network)", "Multi-task Head (predict likes, comments, shares, time, hide)", "Post-ranking Filters (diversity, freshness, ads insertion)", "Real-time Feature Store", "Online Learning Pipeline", "Counter-abuse Models (clickbait, misinformation)", "A/B Testing Platform", "Metrics Dashboard (time spent, meaningful interactions)"]',
'# Facebook News Feed Ranking System

## System Architecture

### 1. Data Collection Pipeline
```python
class DataCollector:
    def __init__(self):
        self.kafka_consumer = KafkaConsumer(''user-events'')
        self.feature_store = FeatureStore()

    def collect_user_signals(self, user_id):
        signals = {
            ''explicit'': {
                ''likes'': self.get_likes(user_id),
                ''comments'': self.get_comments(user_id),
                ''shares'': self.get_shares(user_id)
            },
            ''implicit'': {
                ''dwell_time'': self.get_dwell_times(user_id),
                ''scroll_depth'': self.get_scroll_patterns(user_id),
                ''click_through'': self.get_clicks(user_id)
            },
            ''social'': {
                ''friend_interactions'': self.get_friend_activity(user_id),
                ''group_memberships'': self.get_groups(user_id)
            }
        }
        return signals
```

### 2. Feature Engineering
- **User Features**: Demographics, interests, past behavior
- **Content Features**: Type, creator, recency, engagement metrics
- **Contextual Features**: Time of day, device, location
- **Social Features**: Friend interactions, network effects

### 3. Ranking Model
```python
class NewsFeedRanker:
    def __init__(self):
        self.relevance_model = self.load_relevance_model()
        self.quality_model = self.load_quality_model()
        self.diversity_optimizer = DiversityOptimizer()

    def rank_posts(self, user_id, candidate_posts):
        features = []
        for post in candidate_posts:
            feature_vector = self.extract_features(user_id, post)
            features.append(feature_vector)

        # Multi-objective optimization
        relevance_scores = self.relevance_model.predict(features)
        quality_scores = self.quality_model.predict(features)

        # Combine scores
        final_scores = 0.7 * relevance_scores + 0.3 * quality_scores

        # Apply diversity
        ranked_posts = self.diversity_optimizer.rerank(
            candidate_posts, final_scores
        )

        return ranked_posts[:100]  # Return top 100
```

### 4. Real-time Serving
- **Architecture**: Microservices with API Gateway
- **Caching**: Redis for hot user feeds
- **Fallback**: Pre-computed feeds for cold start

### 5. Evaluation & Monitoring
- **Online Metrics**: CTR, Time Spent, User Retention
- **Offline Metrics**: NDCG@k, MAP, Coverage
- **A/B Testing**: Statistical significance at p < 0.05

## Scalability Considerations
- Handle 2B+ daily active users
- Sub-second latency requirements
- Horizontal scaling with sharding
- Multi-region deployment');


-- Question 53: Design Instagram Reels Recommendation System
-- Design Instagram Reels Recommendation System (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(53, 2, 'Design Instagram Reels Recommendation System', 'hard',
'Design the ML system powering Instagram Reels recommendations - a TikTok competitor serving short-form video to 2B+ users with multi-modal understanding.',
'["recommendation", "multi-modal", "video", "meta", "instagram", "reels", "cold-start"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(53,
'Instagram Reels competes with TikTok by recommending engaging short-form videos. The system must:
- Understand video content (visual, audio, text, music)
- Cold start: recommend videos to new users and new videos to users
- Optimize for watch time and completion rate
- Handle the "creator economy" (help creators grow)
- Prevent filter bubbles while maximizing engagement
- Support audio trends (viral sounds)
- Real-time: new videos should surface quickly
- Multi-modal: video, audio, captions, hashtags, music

Key challenge: Unlike Feed (friends/following), Reels is discovery-based like TikTok.',
'["Multi-modal understanding (video, audio, text, music)", "Real-time recommendations (<100ms)", "Cold start for new users and new content", "Optimize for watch time and completion rate", "Surface trending content quickly (viral detection)", "Creator growth (help small creators get discovered)", "Audio-based features (trending sounds)", "Prevent filter bubbles (content diversity)", "Handle billions of videos", "Mobile-first (lightweight models)"]',
'{"multi_modal": "How video, audio, text signals are combined", "cold_start": "Strategy for new users and new content", "viral_detection": "Identifying trending content early", "model_architecture": "Two-tower, transformers, or hybrid approach", "feature_engineering": "Video embeddings, audio features, engagement signals", "training": "Handling data skew (power law distribution)", "serving": "Low-latency multi-modal inference", "metrics": "Watch time, completion rate, user retention"}',
'["Video Understanding (frame-level embeddings)", "Audio Understanding (music/sound embeddings)", "Text Understanding (captions, hashtags)", "Two-Tower Model (user tower + video tower)", "Candidate Retrieval (ANN search)", "Ranking Model (watch time prediction)", "Trending Detection System", "Creator Recommendation Engine", "Real-time Feature Pipeline", "A/B Testing for Reels"]',
'# Instagram Reels Recommendation System

## System Overview

### 1. Content Understanding Pipeline
```python
class ReelsContentProcessor:
    def __init__(self):
        self.video_model = VideoUnderstandingModel()
        self.audio_model = AudioAnalyzer()
        self.text_extractor = TextExtractor()

    def process_reel(self, reel_id, video_path):
        # Extract visual features
        visual_features = self.video_model.extract_features(video_path)

        # Extract audio features
        audio_features = self.audio_model.analyze(video_path)

        # Extract text (captions, hashtags)
        text_features = self.text_extractor.extract(reel_id)

        # Combine into embedding
        reel_embedding = self.combine_features(
            visual_features, audio_features, text_features
        )

        return reel_embedding
```

### 2. User Interest Modeling
```python
class UserInterestModel:
    def build_profile(self, user_id):
        # Short-term interests (last 24 hours)
        recent_views = self.get_recent_views(user_id)
        short_term = self.aggregate_embeddings(recent_views, decay=0.9)

        # Long-term interests (30 days)
        historical = self.get_historical_interactions(user_id)
        long_term = self.aggregate_embeddings(historical, decay=0.5)

        # Combine with adaptive weighting
        user_embedding = self.adaptive_combine(short_term, long_term)

        return user_embedding
```

### 3. Recommendation Strategy
- **Exploration vs Exploitation**: 80/20 split
- **Cold Start**: Use trending content + demographic similarity
- **Diversity**: Ensure variety in content types

### 4. Infrastructure
- **Video CDN**: Global edge servers for streaming
- **ML Pipeline**: TensorFlow/PyTorch for model training
- **Feature Store**: Real-time feature serving

## Success Metrics
- User engagement time
- Completion rate
- Share rate
- Creator diversity');


-- Question 54: Design Real-time Ad Targeting & Ranking System
-- Design Real-time Ad Targeting & Ranking System (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(54, 2, 'Design Real-time Ad Targeting & Ranking System', 'hard',
'Design Meta''s ad targeting and ranking system that serves personalized ads to 3B+ users, generating $100B+ annual revenue while balancing user experience.',
'["ads", "ranking", "auction", "revenue", "meta", "ctr-prediction", "conversion"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(54,
'Meta''s ad system is critical infrastructure generating $100B+ revenue. The ML system must:
- Target: Find right users for each ad campaign (audience selection)
- Rank: Order ads by expected value (bid Ã pCTR Ã pConversion)
- Auction: Run real-time ad auction for each impression
- Budget: Manage advertiser budgets and pacing
- Quality: Maintain user experience (not too many ads)
- Privacy: Work with limited data (iOS privacy, GDPR)
- Scale: Billions of users, millions of advertisers, trillions of impressions

Revenue equation: eCPM = bid Ã pCTR Ã pConversion
Goal: Maximize revenue while maintaining user satisfaction.',
'["Real-time ad auction (<50ms per impression)", "Predict CTR (click-through rate)", "Predict conversion probability", "Budget pacing (spend advertiser budgets evenly)", "Audience targeting (find right users for ads)", "Frequency capping (don''t show same ad too much)", "Ad quality scoring (prevent low-quality ads)", "Privacy-preserving (limited tracking)", "Handle billions of users, millions of advertisers", "Revenue optimization vs user experience"]',
'{"auction_mechanism": "Second-price auction, VCG, or generalized second price", "pCTR_model": "Model for click prediction", "pConversion_model": "Model for conversion prediction", "targeting": "How to match ads to users", "budget_pacing": "Algorithm to spend budgets over time", "calibration": "Are predicted probabilities accurate?", "privacy": "How to work with limited data", "revenue_metrics": "eCPM, revenue lift, advertiser ROI"}',
'["Ad Retrieval (find candidate ads)", "CTR Prediction Model", "Conversion Prediction Model", "Ad Auction System", "Budget Pacing Algorithm", "Frequency Capping", "Ad Quality Classifier", "Targeting Engine (lookalike audiences)", "Attribution System (track conversions)", "Real-time Bidding Infrastructure"]',
'# Real-time Ad Targeting & Ranking System

## Architecture Components

### 1. User Profiling Service
```python
class UserProfiler:
    def get_targeting_features(self, user_id):
        return {
            ''demographics'': self.get_demographics(user_id),
            ''interests'': self.get_interests(user_id),
            ''behavior'': self.get_behavioral_signals(user_id),
            ''intent'': self.predict_purchase_intent(user_id)
        }
```

### 2. Ad Auction Engine
```python
class AdAuctionEngine:
    def run_auction(self, user_features, ad_candidates):
        bids = []
        for ad in ad_candidates:
            # Calculate relevance score
            relevance = self.relevance_model.score(user_features, ad)

            # Calculate expected revenue
            ctr = self.ctr_model.predict(user_features, ad)
            expected_revenue = ad.bid * ctr * relevance

            bids.append((ad, expected_revenue))

        # Second-price auction
        bids.sort(key=lambda x: x[1], reverse=True)
        winner = bids[0][0]
        price = bids[1][1] / winner.quality_score

        return winner, price
```

### 3. Real-time Serving
- **Latency Budget**: < 100ms end-to-end
- **Caching Strategy**: Multi-tier (L1: Redis, L2: Memcached)
- **Load Balancing**: Geographic + behavioral sharding

## Performance Requirements
- 10M+ requests/second
- 99.9% availability
- P99 latency < 100ms');


-- Question 55: Design AI Content Moderation System for Meta
-- Design AI Content Moderation System for Meta (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(55, 2, 'Design AI Content Moderation System for Meta', 'hard',
'Design Meta''s content moderation system that detects and removes harmful content (hate speech, violence, spam, misinformation) across Facebook, Instagram, WhatsApp at scale.',
'["content-moderation", "classification", "multi-modal", "safety", "meta", "nlp", "computer-vision"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(55,
'Meta''s content moderation is critical for platform safety. The system must:
- Detect multiple violation types: hate speech, violence, nudity, spam, misinformation, bullying
- Multi-modal: text, images, videos, audio
- Real-time: flag content within seconds
- Multi-language: 100+ languages
- Precision is critical: False positives remove legitimate content
- Recall is critical: False negatives allow harmful content
- Human review: queue borderline content for human moderators
- Adversarial: bad actors constantly try to evade detection
- Scale: billions of posts/day

This is a high-stakes system with regulatory, legal, and ethical implications.',
'["Multi-modal detection (text, image, video, audio)", "Real-time inference (<1s for text, <10s for video)", "Multi-class: hate speech, violence, nudity, spam, etc.", "Multi-language support (100+ languages)", "High precision (>95%) to avoid removing legitimate content", "High recall (>98%) for severe violations", "Human-in-the-loop for borderline cases", "Explainability for appeals", "Adversarial robustness", "Regional policy differences"]',
'{"model_architecture": "Multi-modal models (CLIP, ViT, transformers)", "data_pipeline": "How to get labeled data (human labeling, active learning)", "precision_recall": "Strategy to balance False positives vs False negatives", "adversarial": "Handling adversarial attacks (typos, obfuscation)", "human_loop": "Queue design, reviewer workflow", "explainability": "SHAP, attention, or rule-based explanations", "scaling": "Distributed inference for billions of items", "metrics": "Precision, recall, proactive rate, human review queue size"}',
'["Text Classification (hate speech, spam)", "Image Classification (nudity, violence)", "Video Understanding (frame + audio analysis)", "Multi-modal Fusion", "Human Review Queue", "Active Learning Pipeline", "Adversarial Detection", "Explanation Generator", "Appeal System", "Policy Engine (region-specific rules)"]',
'# AI Content Moderation System

## Multi-Modal Detection Pipeline

### 1. Content Analysis
```python
class ContentModerator:
    def __init__(self):
        self.image_model = ImageModerationModel()
        self.text_model = TextModerationModel()
        self.video_model = VideoModerationModel()

    def moderate(self, content):
        scores = {}

        if content.type == ''image'':
            scores = self.image_model.detect({
                ''violence'': 0.0,
                ''adult'': 0.0,
                ''hate_speech'': 0.0,
                ''self_harm'': 0.0
            })
        elif content.type == ''text'':
            scores = self.text_model.analyze(content.text)

        return self.make_decision(scores)

    def make_decision(self, scores):
        if any(score > 0.9 for score in scores.values()):
            return ''block''
        elif any(score > 0.7 for score in scores.values()):
            return ''human_review''
        else:
            return ''approve''
```

### 2. Human-in-the-Loop
- Queue management for human reviewers
- Active learning from human decisions
- Quality assurance sampling

### 3. Scalability
- Process 100B+ pieces of content daily
- Multi-region deployment
- Edge inference for faster response

## Evaluation Metrics
- Precision/Recall per violation type
- False positive rate < 1%
- Human reviewer agreement rate');


-- Question 56: Design Spam Detection System for Messaging
-- Design Spam Detection System for Messaging (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(56, 2, 'Design Spam Detection System for Messaging', 'medium',
'Design a real-time spam detection system for Meta Messenger/WhatsApp that identifies and blocks spam, scams, and phishing at scale while preserving user privacy.',
'["spam-detection", "classification", "privacy", "meta", "messaging", "adversarial"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(56,
'Meta''s messaging platforms (Messenger, WhatsApp, Instagram DMs) need spam detection:
- Billions of messages daily
- Real-time detection (<100ms)
- Privacy: End-to-end encrypted (WhatsApp)
- Multi-type: spam, scams, phishing, malware links
- Low False positive rate (legitimate messages blocked)
- Handle adversarial attackers (constantly evolving tactics)
- Multi-language support
- On-device ML (for encrypted messages)

Challenge: Balance spam detection with privacy (can''t read WhatsApp messages).',
'["Real-time detection (<100ms per message)", "Privacy-preserving (work with encrypted messages)", "Multi-type: spam, scams, phishing, malware", "Low False positive rate (<0.1%)", "High recall for dangerous scams (>95%)", "On-device models (for WhatsApp)", "Handle text, images, links, files", "Adversarial robustness", "Multi-language support", "Scale to billions of messages/day"]',
'{"privacy": "How to detect spam without reading content", "on_device": "Lightweight models for mobile devices", "features": "Metadata vs content features", "adversarial": "Handling typos, obfuscation, zero-day attacks", "False_positives": "Strategy to minimize blocking legitimate messages", "link_scanning": "Detecting malicious URLs", "user_reports": "Incorporating user feedback", "metrics": "Precision, recall, proactive detection rate"}',
'["Message Classifier (spam vs ham)", "URL Scanner (malware/phishing detection)", "Image OCR + Classification", "Behavioral Signals (message patterns)", "On-device Model (for WhatsApp)", "Server-side Model (for Messenger)", "User Report System", "Challenge Flows (CAPTCHA for suspected spam)", "Adversarial Detection", "Feedback Loop"]',
'# Spam Detection System for Messaging

## Detection Pipeline

### 1. Feature Extraction
```python
class SpamDetector:
    def extract_features(self, message):
        return {
            ''content'': {
                ''text_similarity'': self.check_template_match(message.text),
                ''url_reputation'': self.check_urls(message.urls),
                ''keyword_density'': self.calculate_spam_keywords(message.text)
            },
            ''behavioral'': {
                ''send_rate'': self.get_send_rate(message.sender),
                ''recipient_diversity'': self.calculate_recipient_entropy(message.sender),
                ''time_pattern'': self.analyze_time_pattern(message.sender)
            },
            ''network'': {
                ''account_age'': self.get_account_age(message.sender),
                ''connection_quality'': self.analyze_connections(message.sender),
                ''report_history'': self.get_report_count(message.sender)
            }
        }
```

### 2. Real-time Classification
- Ensemble of models (RF, XGBoost, DNN)
- Online learning for emerging patterns
- Threshold tuning per market/language

### 3. Actions
- Silent drop
- Captcha challenge
- Rate limiting
- Account suspension

## Performance Requirements
- Process 100M+ messages/minute
- < 10ms classification latency
- False positive rate < 0.01%');


-- Question 57: Design A/B Testing Platform for ML Experiments
-- Design A/B Testing Platform for ML Experiments (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(57, 2, 'Design A/B Testing Platform for ML Experiments', 'medium',
'Design Meta/Atlassian''s ML experimentation platform that enables safe, fast, statistically rigorous A/B testing of ML models in production.',
'["ab-testing", "experimentation", "infrastructure", "statistics", "meta", "atlassian"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(57,
'Large tech companies run thousands of A/B tests. The platform must:
- Enable data scientists to run ML experiments easily
- Random assignment (users to treatment/control)
- Metric computation (online + offline metrics)
- Statistical testing (p-values, confidence intervals)
- Heterogeneous treatment effects (does it work for all users?)
- Interference handling (network effects, spillover)
- Multi-armed bandits (explore/exploit)
- Staged rollouts (1% â 10% â 100%)
- Automated monitoring (metric guardrails)

Meta runs 1000s of experiments concurrently. Atlassian tests product changes.',
'["Support 1000s of concurrent experiments", "Random assignment with stratification", "Real-time metric computation", "Statistical testing (t-test, bootstrap)", "Heterogeneous treatment effects", "Network effect handling", "Multi-armed bandits", "Automated rollout (gradual)", "Metric guardrails (auto-disable bad experiments)", "Experiment analysis dashboard"]',
'{"randomization": "Proper random assignment, avoiding bias", "metrics": "How to compute online and offline metrics", "statistics": "Statistical rigor, multiple testing correction", "interference": "Handling network effects, spillover", "bandits": "Explore/exploit strategies", "infrastructure": "Scalable, low-latency", "usability": "Easy for data scientists to use", "safety": "Guardrails to prevent bad launches"}',
'["Randomization Service", "Experiment Configuration System", "Metric Computation Pipeline", "Statistical Testing Engine", "Bandit Algorithm", "Staged Rollout Controller", "Metric Guardrails", "Experiment Dashboard", "Heterogeneous Treatment Effect Analysis", "Interference Detection"]',
'# A/B Testing Platform for ML Models

## Platform Architecture

### 1. Experiment Configuration
```python
class ExperimentConfig:
    def __init__(self, name, hypothesis, metrics):
        self.name = name
        self.hypothesis = hypothesis
        self.primary_metrics = metrics[''primary'']
        self.guardrail_metrics = metrics[''guardrail'']
        self.allocation = {
            ''control'': 0.5,
            ''treatment'': 0.5
        }
        self.minimum_sample_size = self.calculate_sample_size()
```

### 2. Traffic Splitting
```python
class TrafficSplitter:
    def assign_variant(self, user_id, experiment_id):
        # Deterministic assignment using hash
        hash_value = hashlib.md5(
            f"{user_id}_{experiment_id}".encode()
        ).hexdigest()

        bucket = int(hash_value, 16) % 100

        if bucket < 50:
            return ''control''
        else:
            return ''treatment''
```

### 3. Statistical Analysis
```python
class StatisticalAnalyzer:
    def analyze_results(self, experiment_data):
        control = experiment_data[''control'']
        treatment = experiment_data[''treatment'']

        # Calculate lift
        lift = (treatment.mean() - control.mean()) / control.mean()

        # Statistical significance
        t_stat, p_value = stats.ttest_ind(control, treatment)

        # Confidence interval
        ci = self.calculate_confidence_interval(control, treatment)

        return {
            ''lift'': lift,
            ''p_value'': p_value,
            ''confidence_interval'': ci,
            ''recommendation'': self.make_recommendation(lift, p_value)
        }
```

## Key Features
- Sequential testing for early stopping
- Multi-armed bandits for exploration
- Automatic metric computation
- Real-time dashboards');


-- Question 58: Design Search Ranking for Atlassian Products
-- Design Search Ranking for Atlassian Products (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(58, 2, 'Design Search Ranking for Atlassian Products', 'medium',
'Design an ML-powered search system for Atlassian products (Jira, Confluence) that helps users find relevant issues, pages, and projects using natural language queries.',
'["search", "ranking", "nlp", "semantic-search", "atlassian", "enterprise", "jira", "confluence"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(58,
'Atlassian''s products (Jira, Confluence) have extensive search needs:
- Jira: Search issues, projects, filters, boards
- Confluence: Search pages, spaces, attachments, comments
- Cross-product search: Find related items across products
- Natural language: Understand user intent ("bugs from last sprint about login")
- Personalization: Rank based on user''s role, projects, history
- Structured data (Jira fields) + unstructured data (Confluence pages)
- Enterprise scale: 100K+ issues, 50K+ pages per workspace
- Permission-aware (only show what user can access)

Key: Work with limited data (Atlassian is B2B, not consumer scale like Google).',
'["Natural language query understanding", "Multi-source search (Jira, Confluence, comments, attachments)", "Semantic search (beyond keyword matching)", "Personalized ranking", "Permission-aware results", "Sub-second latency", "Handle structured + unstructured data", "Cross-product search", "Auto-complete and suggestions", "Work with limited data (B2B, not web-scale)"]',
'{"query_understanding": "NLP for intent extraction, entity recognition", "semantic_search": "Embeddings for semantic similarity", "ranking": "Learning-to-rank with personalization", "indexing": "Efficient indexing for mixed data types", "permissions": "Secure, fast permission filtering", "personalization": "User context, project access, search history", "limited_data": "How to work with limited training data", "metrics": "Search success rate, CTR, time to find"}',
'["Query Parser (NLP, intent classification)", "Document Indexing (Elasticsearch)", "Semantic Embedding Models (sentence transformers)", "Hybrid Search (keyword + semantic)", "Ranking Model (LambdaMART or neural ranker)", "Permission Filter", "Personalization Layer", "Auto-complete Service", "Cross-product Aggregator", "Click-through Rate Tracker"]',
'# Search Ranking System for Atlassian Products

## Search Architecture

### 1. Query Understanding
```python
class QueryProcessor:
    def process_query(self, query, context):
        # Intent classification
        intent = self.classify_intent(query)

        # Entity extraction
        entities = self.extract_entities(query)

        # Query expansion
        expanded_terms = self.expand_query(query, context)

        return {
            ''original'': query,
            ''intent'': intent,
            ''entities'': entities,
            ''expanded'': expanded_terms,
            ''filters'': self.extract_filters(query)
        }
```

### 2. Multi-Index Search
```python
class MultiProductSearcher:
    def search(self, processed_query, user_context):
        results = []

        # Search across products
        jira_results = self.search_jira(processed_query)
        confluence_results = self.search_confluence(processed_query)
        bitbucket_results = self.search_bitbucket(processed_query)

        # Merge and rank
        all_results = self.merge_results([
            jira_results,
            confluence_results,
            bitbucket_results
        ])

        # Personalize ranking
        personalized = self.personalize(all_results, user_context)

        return personalized[:50]
```

### 3. Ranking Features
- **Textual**: BM25, TF-IDF, Semantic similarity
- **Behavioral**: Click-through rate, dwell time
- **Contextual**: Recency, author authority, team relevance
- **Structural**: Document type, project importance

### 4. Learning to Rank
```python
class LTRRanker:
    def __init__(self):
        self.model = XGBRanker()

    def rank(self, query_features, doc_features, user_features):
        features = self.combine_features(
            query_features, doc_features, user_features
        )
        scores = self.model.predict(features)
        return scores
```

## Performance Requirements
- < 200ms search latency
- Support 100K+ concurrent users
- Index updates < 1 minute
- 99.99% availability');


-- Question 59: Design Real-time Fraud Detection System
-- Design Real-time Fraud Detection System (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(59, 2, 'Design Real-time Fraud Detection System', 'hard',
'Design a real-time fraud detection system for Meta''s payment products (Meta Pay, WhatsApp Pay) that identifies fraudulent transactions with <100ms latency.',
'["fraud-detection", "classification", "real-time", "payments", "meta", "imbalanced-data"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(59,
'Meta''s payment products need fraud detection:
- Real-time: Score transactions in <100ms
- Multi-type fraud: stolen cards, account takeover, fake accounts, money laundering
- Class imbalance: fraud rate <1%
- False positives are costly: block legitimate transactions
- False negatives are costly: allow fraud, chargebacks
- Adversarial: fraudsters constantly adapt
- Explainability: Why was this transaction blocked?
- Regulatory compliance: PCI-DSS, AML, KYC

The system processes millions of transactions daily, losing millions to fraud if ineffective.',
'["Real-time scoring (<100ms per transaction)", "Multi-type fraud detection", "High recall for fraud (>90%)", "Low False positive rate (<2%)", "Handle severe class imbalance (<1% fraud)", "Adversarial robustness", "Explainability for compliance", "Online learning (adapt to new fraud patterns)", "Scale to millions of transactions/day", "Multi-stage: real-time \u2192 post-transaction analysis"]',
'{"model": "Gradient boosting, neural networks, or ensemble", "features": "Transaction, user, device, behavioral features", "imbalance": "Handling class imbalance (SMOTE, class weights)", "adversarial": "Detecting novel fraud patterns", "latency": "Sub-100ms inference", "explainability": "SHAP, rule-based explanations", "online_learning": "Continuous model updates", "metrics": "Precision, recall, F1, fraud loss, False positive rate"}',
'["Real-time Transaction Scorer", "Feature Engineering Pipeline", "Fraud Detection Model (GBDT or NN)", "Rule Engine (known fraud patterns)", "Anomaly Detector (novel fraud)", "Device Fingerprinting", "Behavioral Analytics (velocity checks)", "Post-transaction Analysis", "Explainability Module", "Feedback Loop (confirmed fraud cases)"]',
'# Real-time Fraud Detection System

## Complete Implementation covered in main solutions above');


-- Question 60: Design Video Understanding System for Meta
-- Design Video Understanding System for Meta (HARD)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(60, 2, 'Design Video Understanding System for Meta', 'hard',
'Design Meta''s video understanding system that analyzes billions of videos to enable search, recommendations, content moderation, and monetization.',
'["video-understanding", "multi-modal", "computer-vision", "meta", "reels", "deep-learning"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(60,
'Meta processes billions of videos (Facebook, Instagram, Reels, Stories). The system must:
- Understand video content: objects, actions, scenes, audio, text
- Enable video search ("find videos of surfing in Hawaii")
- Power recommendations (similar videos)
- Content moderation (detect violations)
- Ad placement (find ad-safe content)
- Thumbnail selection (pick engaging frame)
- Auto-captions (accessibility)
- Copyright detection (match against known content)

Challenge: Video processing is expensive (compute, storage). Need efficient models.',
'["Multi-modal understanding (visual, audio, text)", "Scale to billions of videos", "Real-time for short videos (<10s)", "Batch processing for long videos", "Frame-level analysis (scene detection)", "Audio understanding (speech, music, sounds)", "Text extraction (OCR on video)", "Efficient inference (cost-effective)", "Enable search, recommendations, moderation", "Copyright detection"]',
'{"model_architecture": "Video transformers, 3D CNNs, or frame sampling", "multi_modal": "How to fuse visual, audio, text signals", "efficiency": "Cost-effective processing at scale", "embeddings": "Quality of video embeddings for search/recommendations", "scene_detection": "Identifying scene boundaries", "audio_processing": "Speech recognition, music detection", "ocr": "Text extraction from video frames", "metrics": "Video search quality, recommendation CTR, moderation accuracy"}',
'["Video Encoder (frame embeddings)", "Audio Encoder (audio embeddings)", "Text Encoder (captions, OCR)", "Multi-modal Fusion", "Scene Detection", "Object/Action Recognition", "Speech-to-Text", "Thumbnail Selector", "Copyright Matcher", "Video Search Index"]',
'# Video Understanding System for Meta

## Architecture Overview

### 1. Video Processing Pipeline
```python
class VideoProcessor:
    def __init__(self):
        self.frame_sampler = FrameSampler(fps=1)
        self.object_detector = YOLOv5()
        self.action_recognizer = I3D()
        self.scene_classifier = ResNet152()

    def process_video(self, video_path):
        # Sample frames
        frames = self.frame_sampler.sample(video_path)

        # Object detection
        objects = []
        for frame in frames:
            detections = self.object_detector.detect(frame)
            objects.extend(detections)

        # Action recognition
        actions = self.action_recognizer.recognize(frames)

        # Scene understanding
        scenes = self.scene_classifier.classify(frames)

        # Generate video embedding
        embedding = self.generate_embedding(objects, actions, scenes)

        return {
            ''objects'': objects,
            ''actions'': actions,
            ''scenes'': scenes,
            ''embedding'': embedding
        }
```

### 2. Applications
- Content recommendation
- Auto-tagging
- Highlight generation
- Safety detection

### 3. Scalability
- Process 1B+ videos daily
- GPU cluster for inference
- Distributed processing with Apache Spark

## Model Architecture
- Transformer-based temporal modeling
- Multi-modal fusion (video + audio + text)
- Self-supervised pre-training');


-- Question 61: Design Real-time Personalization Engine
-- Design Real-time Personalization Engine (MEDIUM)
INSERT INTO questions (id, category_id, title, difficulty, description, tags) VALUES
(61, 2, 'Design Real-time Personalization Engine', 'medium',
'Design a real-time personalization system that adapts Meta/Atlassian products to individual users based on their behavior, preferences, and context.',
'["personalization", "user-modeling", "real-time", "meta", "atlassian", "recommendations"]');

INSERT INTO ml_design_questions (question_id, scenario, requirements, evaluation_criteria, key_components, sample_solution) VALUES
(61,
'Modern products need personalization at scale:
- Meta: Personalize Feed, Reels, notifications, ads
- Atlassian: Personalize Jira dashboards, Confluence recommendations
- Real-time: Update preferences as user interacts
- Cold start: New users have no history
- Context: Time of day, device, location matter
- Privacy: Limited data collection
- Scale: Billions of users
- Latency: <50ms per request

Goal: Show the right content to the right user at the right time.',
'["Real-time preference updates (<50ms)", "Handle billions of users", "Cold start for new users", "Context-aware (time, device, location)", "Privacy-preserving", "Multi-product personalization", "Efficient user representation (embeddings)", "Online learning (user preferences change)", "A/B testing integration", "Explainability (why this recommendation?)"]',
'{"user_modeling": "How to represent users (embeddings, features)", "real_time": "Low-latency updates and inference", "cold_start": "Strategy for new users", "context": "Incorporating temporal, device, location signals", "online_learning": "Continuous preference updates", "privacy": "Working with limited data", "scalability": "Handling billions of users efficiently", "metrics": "Engagement lift, user satisfaction, CTR"}',
'["User Profile Store (preferences, embeddings)", "Real-time Event Stream (user actions)", "User Embedding Model", "Context Feature Service", "Personalization API", "Cold Start Solver", "Online Learning Pipeline", "A/B Testing Integration", "Privacy Controls", "Explainability Module"]',
'# Real-time Personalization Engine

## System Components

### 1. User Context Engine
```python
class ContextEngine:
    def get_real_time_context(self, user_id):
        return {
            ''session'': {
                ''duration'': self.get_session_duration(user_id),
                ''page_views'': self.get_page_views(user_id),
                ''interactions'': self.get_interactions(user_id)
            },
            ''device'': self.get_device_info(user_id),
            ''location'': self.get_location(user_id),
            ''time'': {
                ''local_time'': self.get_local_time(user_id),
                ''day_of_week'': self.get_day_of_week(user_id)
            }
        }
```

### 2. Recommendation Engine
```python
class PersonalizationEngine:
    def personalize(self, user_id, content_pool):
        # Get user profile
        user_profile = self.profile_service.get(user_id)

        # Get real-time context
        context = self.context_engine.get_real_time_context(user_id)

        # Score content
        scores = []
        for content in content_pool:
            score = self.scoring_model.predict(
                user_profile, content, context
            )
            scores.append(score)

        # Apply business rules
        filtered_scores = self.apply_rules(scores, context)

        # Return top K
        top_k = self.select_top_k(filtered_scores, k=10)

        return top_k
```

### 3. Infrastructure
- **Feature Store**: Feast for feature serving
- **Model Serving**: TensorFlow Serving
- **Caching**: Redis with TTL
- **Message Queue**: Kafka for events

## Performance Requirements
- < 50ms personalization latency
- 1M+ requests/second
- 99.99% availability');

